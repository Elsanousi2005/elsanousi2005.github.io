<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://elsanousi2005.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://elsanousi2005.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2026-01-18T10:58:33+00:00</updated><id>https://elsanousi2005.github.io/feed.xml</id><title type="html">Mostafa Elsanousi</title><subtitle>Computer Engineering student at Virginia Tech focused on embedded systems, FPGA/SoC design, and chip-scale integration. Documenting projects, bring-up notes, and engineering writeups. </subtitle><entry><title type="html">Post 2: Vivado setup, bitstream, and hardware export (XSA)</title><link href="https://elsanousi2005.github.io/blog/2026/post-2-vivado-setup-bitstream-xsa/" rel="alternate" type="text/html" title="Post 2: Vivado setup, bitstream, and hardware export (XSA)"/><published>2026-01-17T00:00:00+00:00</published><updated>2026-01-17T00:00:00+00:00</updated><id>https://elsanousi2005.github.io/blog/2026/post-2-vivado-setup-bitstream-xsa</id><content type="html" xml:base="https://elsanousi2005.github.io/blog/2026/post-2-vivado-setup-bitstream-xsa/"><![CDATA[<p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_001.png" alt="The image shows a very long, narrow horizontal strip of uniform white/light-gray color across the frame with no discernible objects, text, or features."/></p> <p><strong>Author(s):</strong> Mostafa Elsanousi, <a href="https://github.com/muhammadfarhan720">Muhammad Farhan Azmine</a></p> <p><strong>Publication Date:</strong> 2026-01-17</p> <p><strong>Target Board:</strong> AMD/Xilinx ZC702 (xc7z020 Zynq-7000)<br/><strong>Toolchain:</strong> Vivado 2025.1, Vitis 2025.1<br/><strong>Keywords:</strong> Zynq, GEM0, Ethernet, MIO, RGMII, lwIP, UDP, AXI, AXI4-Lite, SmartConnect, GPIO</p> <h2 id="code-and-resources">Code and Resources</h2> <p>All project materials for this Ethernet bring-up are in my repository: <a href="https://github.com/Elsanousi2005/zc702-ps-ethernet-udp-gpio-inverter">ZC702 Ethernet Bring-up Repository</a>.</p> <p>It includes the Vivado project (.xpr), the block design, exported hardware (.xsa/.hwh), the Vitis bare-metal sources for both the TCP echo example and the UDP inverter application, plus the host-side Python script used to send UDP test vectors.</p> <p>You can open the hardware project directly in Vivado (File -&gt; Open Project -&gt; select the .xpr).</p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_002.png" alt="The image is mostly blank white with a thin dark gray/black horizontal bar running across the very top edge. No other objects, text, or details are visible - it looks like a cropped header or an empty page/screenshot."/></p> <h2 id="1-introduction">1. Introduction</h2> <p>This post documents the Vivado hardware build for the ZC702 Ethernet bring up project. The design has two goals. First, it enables the Zynq PS Ethernet controller GEM0 and routes it through MIO to the onboard PHY and RJ45 connector. Second, it implements a minimal PL datapath that the PS can access through AXI memory mapped registers, using AXI GPIO OUT, an inverter, and AXI GPIO IN. The output of this post is a generated bitstream and a matching XSA for Vitis.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_003.png" alt="A Vivado block-design diagram for a Zynq-7000 system showing a small AXI-based hardware graph: - Core blocks: - processing_system_7_0 (ZYNQ7 processing system) with M_AXI_GP0 interface, DDR and FIXED_IO pins. - rst_ps7_0_50M (Processor System Reset) providing reset/clock-related reset signals. - axi_interconnect_0 (AXI Interconnect) tying the PS M_AXI_GP0 master to AXI slaves. - Two AXI GPIO peripherals: axi_gpio_in and axi_gpio_out. - util_vector_logic_0 (vector logic, marked Discontinued) between the GPIO blocks. - Connections: - M_AXI_GP0 from the Zynq PS connects into the AXI Interconnect which fans out S_AXI to the two AXI GPIO blocks. - Reset/clock/reset-assert signals flow from rst_ps7_0_50M into the interconnect and GPIO blocks. - The gpio_io31:0 port from axi_gpio_in feeds the util_vector_logic_0 Op131:0; the logic output Res31:0 connects to gpio_io31:0 of axi_gpio_out. - DDR and FIXED_IO are routed out from the processing system block. Overall the diagram depicts a PS-driven AXI bus controlling an input GPIO, applying vector logic, and driving an output GPIO, with reset and clock management."/></p> <p><em>Figure 1: Final system overview, PS Ethernet plus PS&lt;-&gt;PL AXI GPIO loopback</em></p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_004.png" alt="Diagram of a UDP-based control path between a Host PC and an FPGA SoC split into Processing System (PS) and Programmable Logic (PL): - Left: Host PC running a UDP client. - Sends a 4-byte UDP datagram to the PS. - Receives an 8-byte UDP reply (sequence labeled &quot;W then R&quot;). - Middle: Processing System block - PS App: an lwIP UDP server. - GEM0 MAC and lwIP handle Ethernet/UDP. - M_AXI_GP0 (AXI4-Lite master) used by the PS app to access PL registers. - Right: Programmable Logic block - AXI GPIO OUT (registers written by PS). - A 32-bit NOT logic block that inverts the 32-bit GPIO lines. - AXI GPIO IN (registers read by PS), connected from the NOT output. - Data flow summary: - Host -&gt; PS (4-byte UDP) -&gt; PS writes via AXI4-Lite to AXI GPIO OUT. - PL performs bitwise NOT and updates AXI GPIO IN. - PS reads AXI GPIO IN and sends an 8-byte UDP reply back to Host."/></p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_005.png" alt="A wide, very thin rectangular image that is almost entirely white and featureless - no visible objects, text, or distinct markings."/></p> <p><em>Figure 2: Overall PS-PL loop for the UDP inverter: host datagram -&gt; lwIP -&gt; AXI-Lite write -&gt; PL invert -&gt; AXI-Lite read -&gt; UDP reply</em></p> <h2 id="2-project-creation-and-block-design-setup">2. Project creation and block design setup</h2> <p>Create a new Vivado project targeting the ZC702 board (or the xc7z020 device if board files are not installed). Then create a block design, for example design_1.</p> <p>At this stage, the only required external interfaces are the PS MIO pins for Ethernet and the standard programming and UART interfaces used for bring up. The PL portion of this design is fully internal and does not require custom XDC constraints for external PL pins.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_006.png" alt="- Screenshot of the Vivado ML Edition (Vivado 2025.2) application showing the &quot;New Project&quot; wizard. - Dialog titled &quot;Default Part&quot; with the &quot;Boards&quot; tab active; a list of evaluation boards is displayed (e.g., Spartan-7 SP701, Zynq 7000 ZC702, Zynq UltraScale+ ZCU104). - The Zynq 7000 ZC702 Evaluation Board row is highlighted; columns show preview images, status (&quot;Installed&quot;), vendor (xilinx.com), file version, part number, I/O pin count, and board revision. - Controls visible: vendor/name filters, search box, Refresh button, and toolbar icons above the list. - Bottom of the dialog shows navigation buttons: Back, Next (enabled), Finish (disabled), Cancel. - Background of the IDE shows left sidebar panels: Quick Start, Tasks, and Learning Center; application titlebar at top-left displays AMD Vivado ML Edition."/></p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_007.png" alt="The image is a very wide, thin horizontal strip that is almost entirely blank/white, with a faint, thin horizontal gray line running near the top and no other discernible objects or details."/></p> <p><em>Figure 3: Vivado project configuration showing ZC702 or xc7z020 selection</em></p> <h2 id="3-processing-system-configuration-for-gem0-ethernet-on-mio">3. Processing System configuration for GEM0 Ethernet on MIO</h2> <p>Add the Zynq7 Processing System IP block (processing_system7_0) and open the PS configuration GUI. Vivado will typically prompt you to Run Block Automation. Accept this prompt so Vivado applies the board preset, creates the required DDR and FIXED_IO external interfaces, and enables the standard PS clocks and connections needed for a valid design. The configuration that matters for this project is confirmed by the generated hardware handoff file.</p> <h3 id="31-enable-enet0-and-route-it-on-mio">3.1. Enable ENET0 and route it on MIO</h3> <p>In this design, Ethernet 0 (GEM0) is enabled and routed through MIO 16 through 27 to reach the onboard PHY using the RGMII signal group. MDIO is also enabled on MIO 52 and 53 so the PS can manage the PHY, including reading link status and completing auto negotiation. For readability, the mapping is presented through the PS configuration screenshots rather than listing every signal name.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_008.png" alt="The screenshot shows Xilinx Vivado 2025.2 with a block-design editing session open. Key elements visible: - Main window title: &quot;zynq-axi-eth-final - C:/Users/.../zynq-axi-eth-final/zynq-axi-eth-final.xpr - Vivado 2025.2&quot;. - Left Flow Navigator with sections: Project Manager, IP Integrator (highlighted), Simulation, RTL Analysis, Synthesis, Implementation, Program and Debug. - Center area: &quot;BLOCK DESIGN&quot; tab with a modal dialog titled &quot;Re-customize IP - ZYNQ7 Processing System (5.5)&quot;. - Dialog shows the MIO Configuration page: a tree listing I/O Peripherals with &quot;ENET 0&quot; expanded and &quot;MDIO&quot; selected. - A table of MIO assignments (columns: Peripheral, IO, Signal, IO Type, Speed, Pullup, Direction) mapping Ethernet signals to MIO pins (e.g., Enet0 MIO16..MIO27, MIO16..21 entries) and IO Type set to HSTL 1.8V. - Bottom of dialog has OK and Cancel buttons. - Background shows the block design canvas and toolbar; top-right status shows &quot;write_bitstream Complete&quot; with a green check."/></p> <h3 id="32-phy-reset-control">3.2. PHY reset control</h3> <p>In this exported configuration, ENET reset control is not enabled from the PS configuration. In other words, the PS is not driving a dedicated ENET reset MIO pin in this design. The PHY reset behavior therefore relies on the board level reset circuitry and PHY strap configuration.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_009.png" alt="The image is almost entirely blank white with a very thin, faint horizontal gray line across the middle; no other objects, text, or distinct features are visible."/></p> <p><em>Figure 4: PS7 configuration showing ENET0 enabled and mapped to MIO 16-27 and MDIO enabled and mapped to MIO 52 and 53</em></p> <h2 id="4-ps-to-pl-clocking-and-axi-master-port">4. PS to PL clocking and AXI master port</h2> <p>The PL peripherals are accessed by the ARM cores through a PS to PL AXI general purpose master port.</p> <h3 id="41-fabric-clock">4.1. Fabric clock</h3> <p>This design uses a single PL clock domain driven by FCLK_CLK0, configured for 50 MHz. In the handoff, the clock is generated from the IO PLL with divisors that result in 50 MHz.</p> <p>This clock drives:</p> <ul> <li>The PS M AXI GP0 interface clock</li> <li>The AXI SmartConnect clock</li> <li>Both AXI GPIO clocks</li> </ul> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_010.png" alt="Screenshot of the Xilinx Vivado IDE showing an open Block Design and a modal dialog titled &quot;Re-customize IP - ZYNQ7 Processing System (5.5)&quot;. The dialog is on the Clock Configuration page (Basic Clocking tab). In the table the PL Fabric Clocks section shows FCLK_CLK0 checked and highlighted (yellow) with Clock Source &quot;IO PLL&quot;, Requested Frequency &quot;50&quot;, Actual Frequency &quot;50.000000&quot;, and Range &quot;0.100000 : 250.000000&quot;. The IDE left Flow Navigator lists project steps (Project Manager, IP Integrator, Simulation, RTL Analysis, Synthesis, Implementation, Program and Debug). The block design canvas and an AXI slave block are visible at right; bottom panes show Tcl Console, Messages, Log, Reports, and Design Runs. The Vivado window title and toolbar are visible across the top."/></p> <h3 id="42-enable-m_axi_gp0">4.2. Enable M_AXI_GP0</h3> <p>The PS exports M_AXI_GP0 for memory mapped access into the PL. In the handoff, this port is configured for a 50 MHz domain and provides the master interface used to reach both AXI GPIO blocks through SmartConnect.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_011.png" alt="- Screenshot of Xilinx Vivado (Vivado 2025.2) showing the IP Integrator Block Design workspace. - A modal titled &quot;Re-customize IP - ZYNQ7 Processing System (5.5)&quot; is open, with the &quot;PS-PL Configuration&quot; tab selected. - In the modal the &quot;General&quot; section is expanded and &quot;AXI Non Secure Enablement&quot; options are shown; the &quot;M AXI GP0 interface&quot; (labelled &quot;GP Master AXI Interface / M AXI GP0 interface&quot;) appears checked while &quot;M AXI GP1 interface&quot; is not. - Left pane shows the Flow Navigator (Project Manager, IP Integrator, Simulation, RTL Analysis, Synthesis, Implementation, Program and Debug). - Background shows the block design canvas with a PS block and an AXI SmartConnect (S00_AXI, S01_AXI) and the Vivado status bar and console tabs at the bottom."/></p> <p><em>Figure 5: PS7 clock configuration showing FCLK0 enabled at 50 MHz</em></p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_012.png" alt="The image is a very narrow, wide horizontal strip that's almost entirely white/very light gray, with no distinct objects or features visible - essentially a blank, high-aspect-ratio white bar."/></p> <p><em>Figure 6: PS7 configuration showing M_AXI_GP0 enabled</em></p> <h2 id="5-pl-datapath-smartconnect-axi-gpio-and-inverter-logic">5. PL datapath: SmartConnect, AXI GPIO, and inverter logic</h2> <p>Add the following IP blocks:</p> <ul> <li>AXI SmartConnect</li> <li>AXI GPIO, configured as 32 bit output</li> <li>AXI GPIO, configured as 32 bit input</li> <li>Inline Utility Vector Logic, configured as bitwise NOT for a 32 bit vector</li> </ul> <h3 id="51-smartconnect-routing">5.1. SmartConnect routing</h3> <p>SmartConnect connects the PS master M_AXI_GP0 to multiple AXI Lite slave peripherals. In this design, it fans out from the PS master to the two AXI GPIO blocks. Ensure that the SmartConnect is configured to have two slave interfaces and one master interface.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_013.png" alt="Screenshot of Xilinx Vivado's IP Integrator showing a &quot;Re-customize IP&quot; dialog for &quot;AXI SmartConnect (1.0)&quot;. Main elements: - Dialog title bar: &quot;AXI SmartConnect (1.0)&quot; with tabs for Documentation and IP Location. - Center/right pane: &quot;Component Name smartconnect_0&quot; and Standard Properties section (highlighted) showing: - Number of Slave Interfaces: 1 - Number of Master Interfaces: 2 - Number of Clock Inputs and Has ARESETN Input fields - Left pane: small block diagram of the AXI SmartConnect node labeled S00_AXI with ports aclk, aresetn and outputs M00_AXI, M01_AXI. - Bottom of dialog: &quot;OK&quot; and &quot;Cancel&quot; buttons. - Background: Vivado IDE workspace with Flow Navigator on the left (Project Manager, IP Integrator, Synthesis, Implementation, etc.), a block design on the right with GPIO blocks, and bottom panes (Tcl Console, Messages, Log, Reports). Title bar shows project path and Vivado 2025.2."/></p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_014.png" alt="- Screenshot of Xilinx Vivado (version 2025.2) showing the IP Integrator Block Design view. - Left pane: Flow Navigator with sections (Project Manager, IP Integrator, Simulation, RTL Analysis, Synthesis, Implementation, Program and Debug). - Central area: Block Design canvas (design_2) with a Zynq-7000 Processing System block labeled processing_system7_0. - processing_system7_0 connects to DDR and FIXED_IO on the right, and its M_AXI_GP0 master goes into an AXI SmartConnect (smartconnect_0). - smartconnect_0 fans out to two AXI GPIO peripherals (axi_gpio_out and axi_gpio_in); AXI signals (S_AXI, aclk, aresetn) are visible. - A green banner at top of canvas reads &quot;Designer Assistance available. Run Connection Automation.&quot; - Top toolbar, tabs (Diagram, Address Editor, Address Map) and bottom panes (Tcl Console, Messages, Log, Reports, Design Runs) are visible; status at upper-right shows &quot;write_bitstream Complete.&quot;"/></p> <p><em>Figure 7: AXI SmartConnect configuration page</em></p> <h3 id="52-axi-gpio-configuration">5.2. AXI GPIO configuration</h3> <p>The AXI GPIO blocks, instantiated as axi_gpio_out and axi_gpio_in in the block design, are configured as single channel 32 bit peripherals:</p> <ul> <li>axi_gpio_out is all outputs, width 32</li> <li>axi_gpio_in is all inputs, width 32</li> </ul> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_015.png" alt="Screenshot of Xilinx Vivado's IP Integrator interface showing the &quot;Re-customize IP&quot; dialog for &quot;AXI GPIO (2.0)&quot;. The dialog's &quot;IP Configuration&quot; tab is selected and highlights GPIO settings: &quot;All Outputs&quot; checked, GPIO Width=32, Default Output Value=0x00000000, Default Tri State Value=0xFFFFFFFF. &quot;Enable Dual Channel&quot; is unchecked and the second GPIO channel fields are disabled. In the background is the block design with an S_AXI GPIO block and connections to DDR and FIXED_IO; the Flow Navigator and project panes are visible at the left. The dialog has &quot;OK&quot; and &quot;Cancel&quot; buttons at the bottom."/></p> <p><em>Figure 8: Block design showing M_AXI_GP0 connected through SmartConnect to two AXI GPIO peripherals</em></p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_016.png" alt="Image of the Xilinx Vivado IP Integrator GUI showing the &quot;Re-customize IP&quot; dialog for &quot;AXI GPIO (2.0)&quot;. Key visible items: - Dialog title &quot;Re-customize IP&quot; and component name &quot;axi_gpio_in&quot;. - Two tabs: &quot;Board&quot; and &quot;IP Configuration&quot; (IP Configuration active). - GPIO configuration panel: &quot;All Inputs&quot; checked, &quot;GPIO Width&quot; = 32, &quot;Default Output Value&quot; = 0x00000000, &quot;Default Tri State Value&quot; = 0xFFFFFFFF. Option to &quot;Enable Dual Channel&quot; and &quot;Enable Interrupt&quot; present but not enabled. - Left side shows block diagram with an AXI GPIO block labeled with ports (S_AXI, s_axi_aclk, s_axi_aresetn). - Background Vivado IDE elements: Flow Navigator on the left (PROJECT MANAGER, IP INTEGRATOR, etc.), top menu and window title indicating Vivado 2025.2, and status &quot;write_bitstream Complete&quot; in the top-right. Buttons &quot;OK&quot; and &quot;Cancel&quot; at bottom of the dialog."/></p> <p><em>Figure 9: AXI GPIO OUT configuration page</em> Figure 10: AXI GPIO IN configuration page*</p> <h3 id="53-inverter-logic">5.3. Inverter logic</h3> <p>The PL transform is intentionally simple. The output bus from axi_gpio_out is inverted and wired into the input bus of axi_gpio_in. In the synthesized netlist, this becomes a direct inversion assignment, which is ideal for a sanity datapath.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_017.png" alt="A screenshot of Xilinx Vivado (Vivado 2025.2) showing an IP Integrator block design and an open IP customization dialog. - Main window: Vivado project titled &quot;zynq-axi-eth-final&quot; (full path shown in the title bar). - Left pane: Flow Navigator with sections like Project Manager, IP Integrator, RTL Analysis, Synthesis, Implementation, Program and Debug. - Center: Block Design canvas (tabs: design_1, design_2) with a ZYNQ Processing System block and an orange Inline Utility Vector Logic block named ilvector_logic_0 connected by nets to the processing system and I/O (DDR, FIXED_IO). - Foreground: &quot;Re-customize IP&quot; dialog for &quot;Inline Utility Vector Logic (1.0)&quot;: - Shows component name (ilvector_logic_0). - Parameter C_SIZE set to 32. - C_OPERATION radio options: and, or, xor, not (one selected). - Left side shows the block symbol with ports Op31:0 and Res31:0. - Status: top-right indicates &quot;write_bitstream Complete&quot; with a green check."/></p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_018.png" alt="A screenshot of Xilinx Vivado (Vivado 2025.2) showing the IP Integrator block design canvas. The main diagram displays a Zynq7 processing_system7_0 on the left, an AXI SmartConnect in the center, and a yellow-highlighted region on the right containing two AXI GPIO IP blocks (axi_gpio_out, axi_gpio_in) and an Inline Utility Vector Logic block (ilvector_logic_0) wired between them. The Zynq block is connected to DDR and FIXED_IO pins at the top and to the SmartConnect via M_AXI_GP0. The toolbar and tabs (Diagram, Address Editor, Address Map) appear above the canvas, and the Flow Navigator (Project Manager, IP Integrator, RTL Analysis, Synthesis, Implementation, Program and Debug) is visible in the left pane. The window title shows the project path (zynq-axi-eth-final) and a &quot;write_bitstream Complete&quot; status in the title bar."/></p> <p><em>Figure 11: Inline Utility Vector Logic configuration page</em></p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_019.png" alt="A very long, narrow, mostly blank white strip with faint gray/black horizontal edges - appears to contain no distinct objects or details."/></p> <p><em>Figure 12: Inline Utility Vector Logic wiring, emphasizing AXI GPIO OUT to AXI GPIO IN through a 32 bit inverter in the PL fabric</em></p> <h2 id="6-pl-bring-up-essentials-resets-and-address-map">6. PL bring up essentials: resets and address map</h2> <h3 id="61-reset-wiring-and-why-it-matters">6.1. Reset wiring and why it matters</h3> <p>The Processor System Reset IP (proc_sys_reset_0) provides a clean, clock synchronized reset strategy for the PL fabric clock domain. It takes an asynchronous reset source from the PS and generates reset signals that deassert safely with respect to the fabric clock. This matters because AXI peripherals and interconnect logic must not leave reset in an uncontrolled manner. If a peripheral is held in reset or an interconnect is not released properly, the PS can stall on the first AXI transaction.</p> <p>In this design, all PL logic runs in a single clock domain driven by processing_system7_0.FCLK_CLK0 at 50 MHz. The PS also provides a corresponding fabric reset signal, FCLK_RESET0_N, which is used as the external reset input to the reset controller. In other words, FCLK_CLK0 clocks the entire AXI fabric, while proc_sys_reset deasserts resets in two stages: first the interconnect, then the peripherals. A typical and recommended wiring is:</p> <ul> <li>proc_sys_reset_0.slowest_sync_clk is driven by FCLK_CLK0</li> <li>proc_sys_reset_0.ext_reset_in is driven by FCLK_RESET0_N</li> </ul> <p>After adding proc_sys_reset_0, Vivado Connection Automation can be used to connect these clock and reset inputs, and it will also correctly apply the shared clock to the AXI domain:</p> <ul> <li>axi_gpio_in.s_axi_aclk and axi_gpio_out.s_axi_aclk driven by FCLK_CLK0</li> <li>processing_system7_0.M_AXI_GP0_ACLK driven by FCLK_CLK0</li> </ul> <p>However, one reset connection must be verified and in this project it must be applied manually. The AXI interconnect must be released from reset in the correct way, and Connection Automation may not automatically connect the SmartConnect reset input. For a robust AXI reset scheme, the two reset outputs from proc_sys_reset_0 are used as follows:</p> <ul> <li>proc_sys_reset_0.interconnect_aresetn must drive smartconnect_0.aresetn</li> <li>proc_sys_reset_0.peripheral_aresetn must drive the AXI GPIO reset pins, axi_gpio_in.s_axi_aresetn and axi_gpio_out.s_axi_aresetn</li> </ul> <p>This split is intentional. interconnect_aresetn is intended for the AXI routing and handshake infrastructure, while peripheral_aresetn is intended for AXI slave peripherals. Using the correct reset outputs ensures that the SmartConnect fabric becomes stable before peripherals begin responding, and it prevents early AXI transactions from being issued into a partially reset interconnect. With FCLK_CLK0, FCLK_RESET0_N, and these two reset nets wired consistently, the PS to PL AXI path becomes deterministic and software can safely access the AXI GPIO registers at startup.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_020.png" alt="- Screenshot of Xilinx Vivado (title shows Vivado 2025.2) with a Block Design open. - Modal dialog titled &quot;Run Connection Automation&quot; centered over the block design canvas. - Left side of the dialog shows an interface tree (highlighted in yellow) with &quot;All Automation (5 out of 5 selected)&quot; expanded to list: - axi_gpio_in (s_axi_aclk checked) - axi_gpio_out (s_axi_aclk checked) - proc_sys_reset_0 (ext_reset_in and slowest_sync_clk checked) - processing_system7_0 (M_AXI_GP0_ACLK checked) - Right side of the dialog is empty with the prompt &quot;Select an interface pin on the left panel to view its options&quot;. - Dialog has OK and Cancel buttons at the bottom. - Underlying window shows the Block Design canvas with blocks (e.g., Vector Logic) and external ports (DDR, FIXED_IO) and the Vivado Flow Navigator on the left (Project Manager, IP Integrator, Simulation, RTL Analysis, Synthesis, Implementation, Program and Debug)."/></p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_021.png" alt="This is a screenshot of Xilinx Vivado (Vivado 2025.2) showing the IP Integrator Block Design canvas for a project named &quot;zynq-axi-eth-final&quot;. Main visible elements: - Flow Navigator on the left (Project Manager, IP Integrator, Simulation, Synthesis, Implementation, Program and Debug). - Block Design tab with diagram view of a Zynq-based design: - processing_system7_0 (Zynq Processing System) with DDR and FIXED_IO pins. - proc_sys_reset_0 (Processor System Reset). - axi_smartconnect_0 (AXI SmartConnect). - Two AXI GPIO blocks (axi_gpio_out, axi_gpio_in). - ilvector_logic_0 (Inline Utility Vector Logic) connecting GPIO signals. - Colored interconnect wires showing AXI, clocks, resets, and peripheral connections. - Tabs across the top (Diagram, Address Editor, Address Map, design_1.v) and toolbar; status &quot;write_bitstream Complete&quot; in the upper-right."/></p> <p><em>Figure 13: Expected Run Block Automation prompt</em></p> <table style="width: 100%; border-collapse: collapse;"> <thead> <tr> <th style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;"><strong>Legend</strong></th> </tr> </thead> <tbody> <tr> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;"><ul><li>Pink indicates the PL clock domain driven by FCLK\_CLK0.</li><li>Blue indicates the PS sourced fabric reset (FCLK\_RESET0\_N) into proc\_sys\_reset\_0.</li><li>Green indicates peripheral reset (peripheral\_aresetn) applied to the AXI GPIO blocks.</li><li>Brown indicates interconnect reset (interconnect\_aresetn) applied to the AXI SmartConnect.</li><li>Black indicates the purely fabric side loopback datapath implemented with ilvector\_logic\_0 (bitwise NOT).</li></ul></td> </tr> </tbody> </table> <h3 id="62-address-assignment-for-the-pl-peripherals">6.2. Address assignment for the PL peripherals</h3> <p>Address assignment defines the memory map that the PS uses to reach PL peripherals through AXI. Once exported to the XSA, these base addresses become the software contract via xparameters.h, so the Vivado address map and the Vitis platform must remain consistent.</p> <p>Open the Address Editor and assign address ranges for both AXI GPIO blocks. The exported address map in this design is:</p> <ul> <li>axi_gpio_in: 0x4120_0000 to 0x4120_FFFF</li> <li>axi_gpio_out: 0x4121_0000 to 0x4121_FFFF</li> </ul> <p>These addresses are later emitted into xparameters.h and used by the software through XPAR_AXI_GPIO_IN_BASEADDR and XPAR_AXI_GPIO_OUT_BASEADDR.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_022.png" alt="A screenshot of Xilinx Vivado (Vivado 2025.2) showing the IP Integrator's Block Design view with the Address Editor open. Left pane contains the Flow Navigator (Project Manager, IP Integrator, Simulation, RTL Analysis, Synthesis, Implementation, Program and Debug). Center/top shows tabs for Block Design and Address Editor; the Address Editor lists Network 0 -&gt; /processing_system7_0 -&gt; /processing_system7_0/Data (32 address bits : 0x40000000 1G) with two S_AXI slave entries. A right-click context menu is open over the slave list with &quot;Assign All&quot; highlighted; other menu items include Properties, Unassign, Unassign All, Lock, View Address Path, Export/Import, Export to Spreadsheet. Bottom shows Vivado console tabs (Tcl Console, Messages, Log, Reports, Design Runs). Window title indicates project &quot;zynq-axi-eth-final&quot; and a green status &quot;write_bitstream Complete&quot; in the toolbar."/></p> <p><em>Figure 14: Completed Vivado block design with clock sources and clock net routing highlighted</em></p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_023.png" alt="- Screenshot of Xilinx Vivado (title bar: &quot;zynq-axi-eth-final - Vivado 2025.2&quot;) showing the IP Integrator block design workspace. - Main area is the Address Editor tab for a block design (design_2), listing Network 0 -&gt; /processing_system7_0/Data and two AXI GPIO slave interfaces: - /axi_gpio_in/S_AXI - Interface S_AXI, Slave Segment &quot;Reg&quot;, Master Base Address 0x4120_0000, Range 64, Master High Address 0x4120_FFFF - /axi_gpio_out/S_AXI - Interface S_AXI, Slave Segment &quot;Reg&quot;, Master Base Address 0x4121_0000, Range 64, Master High Address 0x4121_FFFF - Left pane shows Flow Navigator with sections: Project Manager, IP Integrator, Simulation, RTL Analysis, Synthesis, Implementation, Program and Debug. - Tabs and panes visible: Diagram, Address Editor, Address Map, design_1.v; bottom shows Tcl Console, Messages, Log, Reports, Design Runs. - Window status indicates &quot;write_bitstream Complete&quot; in the toolbar."/></p> <p><em>Figure 15: Assigning AXI GPIO base addresses in Vivado Address Editor (Assign All)</em></p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_024.png" alt="The image appears to be a wide, nearly uniform white rectangle with no discernible objects, text, or other visible features."/></p> <p><em>Figure 16: Address Editor showing AXI GPIO base addresses</em></p> <h2 id="7-validate-design-generate-wrapper-and-build-outputs">7. Validate design, generate wrapper, and build outputs</h2> <p>Before generating the bitstream, run design validation by right-clicking anywhere on the BD and selecting “Validate Design”. Resolve any warnings that indicate missing clocks, missing resets, or unconnected AXI interfaces and proceed with the following steps.</p> <p>Then complete the standard build flow:</p> <ol> <li>Generate output products for the block design. Ensure that “Synthesis Options” is set to “Global.”</li> <li>Create the HDL wrapper. After, right-click the generated HDL wrapper (.v) and select “Set as Top” and “Let Vivado manage wrapper and auto-update” when prompted. The hierarchy should refresh automatically afterwards.</li> <li>Generate the bitstream (automatically runs Synthesis and Implementation runs) by selecting the option at the bottom of the Flow Navigator under the “Program and Debug” section. Options can be left at their default states. Press “OK” when prompted. Ensure that the process completes without any fatal errors. The implemented design will automatically open, which includes information about the final hardware state after placing and routing on the xc7z020 device.</li> </ol> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_025.png" alt="A screenshot of Xilinx Vivado (title shows a Vivado project window) focused on the IP Integrator block-design view. - Window title: project path and Vivado version (Vivado 2025.2 visible). - Left pane: Flow Navigator with sections (PROJECT MANAGER, IP INTEGRATOR, SIMULATION, RTL ANALYSIS, SYNTHESIS, IMPLEMENTATION, PROGRAM AND DEBUG). &quot;Generate Bitstream&quot; is highlighted in yellow. - Center pane: Sources tree showing design files (design_1_wrapper, design_1, design_2). A context menu is open on a source node; the menu items &quot;Generate Output Products...&quot; and &quot;Reset Output Products...&quot; are highlighted with a yellow box. - Right/main pane: Block design diagram for a Zynq-based system: Zynq processing system block (processing_system7_0), Processor System Reset block, AXI SmartConnect, and two AXI GPIO blocks with colored AXI/interconnect/reset signal lines connecting them. - Top area: Diagram/Address Editor/Address Map tabs and standard toolbar icons."/></p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_026.png" alt="Image: image_026.png"/></p> <p><em>Figure 17: Locations of (1) Generate Output Products, (2) Create HDL Wrapper, and (3) Generate Bitstream</em></p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_027.png" alt="Image: image_027"/></p> <p><em>Figure 18: Block design validation results</em></p> <p>With implementation complete and the bitstream generated successfully, the remaining Vivado work is primarily “handoff” work. In the next section, you export the hardware platform (XSA, including the bitstream) so that the Vitis platform and software are guaranteed to match the exact implemented hardware design (address map, AXI wiring, clocks, and resets).</p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_028.png" alt="Image: image_028"/></p> <p><em>Figure 19: Implementation complete with bitstream generation</em></p> <h2 id="8-export-hardware-and-produce-the-xsa">8. Export hardware and produce the XSA</h2> <p>Export hardware to generate a platform handoff for Vitis. Ensure the export includes the bitstream so the hardware and software remain synchronized during programming and debug. A key rule for bring up work is to treat the bitstream and XSA as a matched pair generated from the same implementation result. If you build software against one XSA but program a different bitstream, PS to PL accesses can fail even when addresses in code appear correct.</p> <p>To export the hardware handoff:</p> <ol> <li>In Vivado, go to File -&gt; Export -&gt; Export Hardware.</li> <li>On the first screen, click Next.</li> <li>On the options screen, check “Include bitstream”.</li> <li>Leave “Include binary” unchecked unless you specifically want an additional binary artifact for a boot flow. If you are not building a boot image, it is fine to omit it.</li> <li>Click Next.</li> <li>Choose a name and location for the exported hardware file, or keep the default name. Make sure there are no naming conflicts with older exports.</li> <li>Click Next, then click Finish.</li> </ol> <p>At the end of this step, you will have an XSA that Vitis can use to create a platform. In the next section, the Vitis platform and application will be built against this exported hardware so that the PS Ethernet and the PS to PL AXI peripherals are addressed and initialized consistently.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_029.png" alt="Image: image_029"/></p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_030.png" alt="Image: image_030"/></p> <p><em>Figure 20: Export hardware dialog showing hardware export settings</em> Figure 21: Export Hardware options with Include bitstream enable*</p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-2-vivado-setup-bitstream-xsa/image_031.png" alt="Image: image_031"/></p> <h2 id="9-closing">9. Closing</h2> <p>At the end of this Vivado flow, the ZC702 hardware platform is complete. GEM0 Ethernet is enabled through MIO to the onboard PHY, and a minimal PL datapath is accessible through AXI Lite registers at a stable address map. The next post covers Vitis platform creation, lwIP integration, and a host side test that verifies Ethernet connectivity and PS to PL register access using the UDP inverter protocol.</p>]]></content><author><name></name></author><category term="zynq"/><category term="zc702"/><category term="ethernet"/><category term="lwip"/><category term="axi"/><category term="vivado"/><category term="vitis"/><category term="ps-pl"/><summary type="html"><![CDATA[This post documents the Vivado hardware build for the ZC702 Ethernet bring up project. The design has two goals.]]></summary></entry><entry><title type="html">Post 3: Vitis Setup and Testing for PS Ethernet and PS to PL Validation</title><link href="https://elsanousi2005.github.io/blog/2026/post-3-vitis-setup-and-testing/" rel="alternate" type="text/html" title="Post 3: Vitis Setup and Testing for PS Ethernet and PS to PL Validation"/><published>2026-01-17T00:00:00+00:00</published><updated>2026-01-17T00:00:00+00:00</updated><id>https://elsanousi2005.github.io/blog/2026/post-3-vitis-setup-and-testing</id><content type="html" xml:base="https://elsanousi2005.github.io/blog/2026/post-3-vitis-setup-and-testing/"><![CDATA[<p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_001.png" alt="Image: image_001.png"/></p> <p><strong>Author(s):</strong> Mostafa Elsanousi, <a href="https://github.com/muhammadfarhan720">Muhammad Farhan Azmine</a></p> <p><strong>Publication Date:</strong> 2026-01-17</p> <p><strong>Target Board:</strong> AMD/Xilinx ZC702 (xc7z020 Zynq-7000)<br/><strong>Toolchain:</strong> Vivado 2025.1, Vitis 2025.1<br/><strong>Keywords:</strong> Zynq, GEM0, Ethernet, MIO, RGMII, lwIP, UDP, AXI, AXI4-Lite, SmartConnect, GPIO</p> <h2 id="code-and-resources">Code and Resources</h2> <p>All project materials for this Ethernet bring-up are in my repository: <a href="https://github.com/Elsanousi2005/zc702-ps-ethernet-udp-gpio-inverter">ZC702 Ethernet Bring-up Repository</a>.</p> <p>It includes the Vivado project (<code class="language-plaintext highlighter-rouge">.xpr</code>), the block design, exported hardware (<code class="language-plaintext highlighter-rouge">.xsa</code>/<code class="language-plaintext highlighter-rouge">.hwh</code>), the Vitis bare-metal sources for both the TCP echo example and the UDP inverter application, plus the host-side Python script used to send UDP test vectors.</p> <p>You can open the hardware project directly in Vivado (File -&gt; Open Project -&gt; select the <code class="language-plaintext highlighter-rouge">.xpr</code>).</p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_002.png" alt="Image: image_002"/></p> <h2 id="1-purpose-and-validation-strategy">1. Purpose and validation strategy</h2> <p>This post covers the Vitis side of the ZC702 bring up. The goal is to validate Ethernet in two layers so that failures are diagnosable rather than ambiguous.</p> <p>The first layer is a known good TCP echo server that exercises only the Processing System network path and lwIP. It provides a baseline that confirms link, IP configuration, and end to end TCP receive and transmit behavior without any dependency on Programmable Logic.</p> <p>The second layer is the project’s UDP inverter service. This validates Ethernet and lwIP UDP, and it also validates PS to PL memory mapped register access by writing to an AXI GPIO output register, passing through a PL inverter datapath, and reading back through an AXI GPIO input register. The application replies to the host with both the original word and the readback word so correctness can be verified in a single transaction.</p> <p>A simple diagnostic rule of thumb is:</p> <p>If TCP works but UDP fails, focus on PS to PL access, PL programming, address map mismatch, or UDP payload handling. If both fail, focus on link, IP configuration, lwIP initialization, or host network setup.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_003.png" alt="Image: image_003"/></p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_004.png" alt="Image: image_004"/></p> <h2 id="2-prerequisites-and-test-setup">2. Prerequisites and test setup</h2> <h3 id="21-required-artifacts">2.1. Required Artifacts</h3> <p>Before starting Vitis bring up, ensure you have:</p> <ol> <li>A Vivado exported hardware handoff generated from the implemented design (<code class="language-plaintext highlighter-rouge">.xsa</code>).</li> <li>The corresponding bitstream from the same Vivado build (<code class="language-plaintext highlighter-rouge">.bit</code>).</li> <li>The Vitis application sources for the TCP echo server and the UDP inverter service.</li> <li>A host side testing environment, ideally a Linux PC with netcat, hexdump, and Python 3 available.</li> </ol> <p>A key bring up rule is to treat the XSA and the bitstream as a matched pair from the same implementation result. If you build software against one XSA but program a different bitstream, PS to PL register access can fail even when addresses in software appear correct.</p> <h3 id="22-host-nic-static-ipv4-configuration">2.2. Host NIC Static IPv4 Configuration</h3> <p>For a direct PC to board cable, the host Ethernet interface must be placed on the same IPv4 subnet as the ZC702. In this project, the board uses a static address of <code class="language-plaintext highlighter-rouge">192.168.1.10/24</code>, so a typical host address is <code class="language-plaintext highlighter-rouge">192.168.1.20/24</code> with a <code class="language-plaintext highlighter-rouge">255.255.255.0</code> netmask. A gateway is optional for a direct link and can be left blank.</p> <ol> <li>Open Settings on Ubuntu, then select Network in the left sidebar.</li> <li>Under Wired, identify the Ethernet connection that is physically connected to the ZC702.</li> <li>Click the gear icon next to that connection to open its configuration dialog.</li> </ol> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_005.png" alt="Image: image_005"/></p> <ol> <li>Go to the IPv4 tab.</li> <li>Change IPv4 Method from Automatic (DHCP) to Manual.</li> </ol> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_006.png" alt="Image: image_006"/></p> <ol> <li>Add an IPv4 address for your host, for example: <ul> <li>Address: <code class="language-plaintext highlighter-rouge">192.168.1.20</code></li> <li>Netmask: <code class="language-plaintext highlighter-rouge">255.255.255.0</code></li> <li>Gateway: (optional for direct link, you may leave it blank)</li> </ul> </li> <li>Click Apply, then toggle the Wired connection off and back on if the settings do not take effect immediately.</li> </ol> <h3 id="23-board-hardware-setup-and-link-indicators">2.3. Board Hardware Setup and Link Indicators</h3> <p>Use the following physical setup before launching any application:</p> <ol> <li>Power: Connect the ZC702 barrel jack supply, then set the board power switch to ON.</li> <li>JTAG (program and run): Connect the USB JTAG cable from the ZC702 to the host PC. This is used by Vitis to program the FPGA and launch the ELF.</li> <li>UART (console): Connect the USB UART cable from the ZC702 to the host PC and verify it enumerates as a serial device. This will be used for a 115200 8N1 console.</li> <li>Ethernet (data path): Connect an RJ45 cable from the ZC702 Ethernet port to the host PC’s Ethernet port (or NIC dongle).</li> </ol> <p>After plugging in Ethernet and powering the board, check the RJ45 LEDs. A healthy setup typically shows:</p> <ul> <li>A steady link LED indicating the PHY has established link.</li> <li>A blinking activity LED once traffic occurs (for example, during ping, TCP connect, or UDP packets).</li> <li>If the LEDs stay completely off, treat it as a physical layer issue first: wrong port, bad cable, wrong host interface selected, or the host NIC is disabled.</li> </ul> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_007.png" alt="Image: image_007"/></p> <p><em>Figure 2: Board setup showing power, JTAG, UART, and Ethernet status LEDs</em></p> <h2 id="3-vitis-platform-setup-from-the-exported-xsa">3. Vitis platform setup from the exported XSA</h2> <p>This workspace uses two platform components, one associated with the TCP echo baseline and one associated with the UDP inverter application. Keeping the baseline and the custom application separated helps prevent BSP setting conflicts occurring during bring up.</p> <h3 id="31-create-a-platform-component-from-the-exported-xsa">3.1. Create a platform component from the exported XSA</h3> <p>In Vitis Unified IDE:</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><strong>1. Launch Vitis and select a workspace.</strong> <img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_008.png" alt="Image: image_008"/></p> <p><strong>2. Create a new Platform Component.</strong></p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_009.png" alt="Image: image_009"/></p> <p><strong>3. Name your platform file and click “Next”</strong></p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_010.png" alt="Image: image_010"/></p> <p><strong>4. Choose Hardware Design and browse to the exported XSA from Vivado.</strong></p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_011.png" alt="Image: image_011"/></p> <p><strong>5. Select the <code class="language-plaintext highlighter-rouge">ps7_cortexa9_0</code> target and choose a standalone domain.</strong></p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_012.png" alt="Image: image_012"/></p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><strong>5. Finish the wizard and build the platform.</strong> <img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_013.png" alt="Image: image_013"/></p> <h3 id="32-platform-and-board-support-package-configuration-for-lwip-and-dhcp">3.2. Platform and Board Support Package configuration for lwIP and DHCP</h3> <p>Before creating either application, configure the Vitis platform so lwIP is included and DHCP behavior is explicit. This avoids the common bring up failure mode where the application builds and runs, but never obtains an IP address because the network stack configuration is incomplete or waiting on DHCP.</p> <h4 id="1-enable-lwip-lwip220-in-the-platform"><strong>1. Enable lwIP (lwip220) in the platform</strong></h4> <p>A. Open the platform component in Vitis. In the Components view, select the platform and open its settings (<code class="language-plaintext highlighter-rouge">{}vitis-comp.json</code>).</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_014.png" alt="Image: image_014"/></p> <p>B. Ensure the <code class="language-plaintext highlighter-rouge">lwip220</code> library is enabled under the standalone domain configuration under the Board Support Package (BSP) so lwIP is actually included in the BSP. Save the change and rebuild the platform so the generated BSP reflects the new library selection.</p> <p>####</p> <p>####</p> <p>####</p> <p>####</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_015.png" alt="Image: image_015"/></p> <h4 id="2-make-dhcp-behavior-explicit-in-bsp-settings"><strong>2. Make DHCP behavior explicit in BSP settings</strong></h4> <p>Next, open the BSP settings panel for the same platform. The lwIP DHCP toggles here control what gets generated into <code class="language-plaintext highlighter-rouge">lwipopts.h</code>, which ultimately determines whether lwIP will attempt to request a DHCP lease.</p> <p>For a direct PC-to-board Ethernet connection with no router or DHCP server, DHCP must be disabled. Otherwise the network stack can wait indefinitely for a lease that never arrives.</p> <p>In this project’s platform configuration, set the following to false (if not already set to false by default):</p> <ul> <li><code class="language-plaintext highlighter-rouge">lwip220_dhcp = false</code></li> <li><code class="language-plaintext highlighter-rouge">lwip220_dhcp_debug = false</code></li> <li><code class="language-plaintext highlighter-rouge">lwip220_dhcp_options = false</code></li> <li><code class="language-plaintext highlighter-rouge">lwip220_lwip_dhcp_does_acd_check</code></li> </ul> <p>With DHCP disabled at the platform level, applications can use deterministic static addressing when their code assigns it.</p> <p>If you are connected to a router and want DHCP instead, enable DHCP in the platform by setting the configurations above to true. In that network protocol mode, the board will obtain a dynamic IP on each run and you should read the assigned address from the UART log.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_016.png" alt="Image: image_016"/></p> <p>It is worth confirming the console routing in Vitis before building. In the platform view, open <code class="language-plaintext highlighter-rouge">vitis-comp.json</code> and check <code class="language-plaintext highlighter-rouge">standalone_stdin</code> and <code class="language-plaintext highlighter-rouge">standalone_stdout</code> under the standalone OS settings. These should point to <code class="language-plaintext highlighter-rouge">UART1</code>, which is the MIO-mapped UART on the ZC702 used for serial logs. This makes sure all <code class="language-plaintext highlighter-rouge">xil_printf</code> output shows up on the UART terminal.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_017.png" alt="Image: image_017"/></p> <h3 id="33-why-two-separate-platform-components-are-recommended">3.3. Why two separate platform components are recommended</h3> <p>This project uses two nearly identical platforms, one for the TCP echo baseline and one for the UDP inverter test. While it is possible to build both applications against a single platform, separating them is a conservative choice for bring-up work because lwIP and BSP settings are platform-scoped.</p> <p>When multiple applications share one platform, changing a lwIP setting for one test silently changes the environment for the other. Separate platforms keep each test’s BSP stable and reproducible, and they make debugging more straightforward when comparing a known good baseline against the full system validation resulting in cleaner and more modular code.</p> <p>Port numbers and protocol behavior are application level details and are covered in the next section when the TCP echo and UDP inverter applications are created and run.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_018.png" alt="Image: image_018"/></p> <h2 id="4-section-a-baseline-validation-using-the-lwip-tcp-echo-server">4. Section A: Baseline validation using the lwIP TCP echo server</h2> <h3 id="41-what-the-tcp-echo-server-does">4.1. What the TCP echo server does</h3> <p>The TCP echo server listens on a TCP port and echoes back any bytes received from the host. This validates the PS Ethernet path end to end, including lwIP receive, TCP processing, and lwIP transmit. Because it does not touch PS to PL peripherals, it isolates network bring-up from PL issues.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_019.png" alt="Image: image_019"/></p> <h3 id="42-build-and-setup-steps-in-vitis">4.2. Build and setup steps in Vitis</h3> <h2 id="1-create-a-new-application-component-from-an-example-template"><strong>1. Create a new Application Component from an example template</strong></h2> <p>In Vitis, select File -&gt; then select New Example.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_020.png" alt="Image: image_020"/></p> <h2 id="2-select-the-template-from-the-example-list-choose-lwip-echo-server-then-click-create-application-component-from-template"><strong>2. Select the template</strong> From the example list, choose lwIP Echo Server, then click Create Application Component from Template.</h2> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_021.png" alt="Image: image_021"/></p> <h2 id="3-name-the-application-and-select-the-platform"><strong>3. Name the application and select the platform</strong></h2> <ul> <li>Enter a non conflicting application name (for example <code class="language-plaintext highlighter-rouge">lwip_echo_server_baseline</code>).</li> <li>When prompted, select the platform component intended for the lwIP echo server baseline test.</li> <li>The application domain will be generated automatically to match the platform domain.</li> <li>Click Finish.</li> </ul> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_022.png" alt="Image: image_022"/></p> <h2 id="4-edit-1-choose-the-tcp-listening-port"><strong>4. Edit 1: Choose the TCP listening port</strong></h2> <p>Open <code class="language-plaintext highlighter-rouge">echo.c</code> in the newly created lwIP Echo Server application. The Vitis lwIP echo server template defines the listening port on line 100 as:</p> <ul> <li><code class="language-plaintext highlighter-rouge">unsigned port = 7;</code> (line 100)</li> </ul> <p>For this project, set the port to <code class="language-plaintext highlighter-rouge">6001</code> instead (for example, <code class="language-plaintext highlighter-rouge">unsigned port = 6001;</code>). Port selection is an application choice. The key requirement is simply that the server port in <code class="language-plaintext highlighter-rouge">echo.c</code> matches the port you use in host testing and, ideally, any corresponding UART banner text you include in your write up.</p> <p>In this tutorial, the baseline TCP validation is performed on port 6001, so all TCP testing commands in this section will target 6001.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_023.png" alt="Image: image_023"/></p> <h2 id="5-edit-2-set-a-board-specific-mac-address-recommended-best-practice"><strong>5. Edit 2: Set a board specific MAC address (recommended best practice)</strong></h2> <p>Open <code class="language-plaintext highlighter-rouge">main.c</code> and locate the MAC address definition on line 128. The stock example uses a template MAC address value that often still works in a single board, direct PC to board setup, because there are no other devices competing with the same MAC on that isolated link.</p> <p>Even though it is not strictly required for an isolated test, we still replace the template MAC with a board specific MAC address. This is the correct long term practice for repeatability and reuse. If you later connect the board to a network with other devices or a DHCP server, duplicate MAC addresses can cause subtle failures such as ARP confusion or DHCP lease collisions. Using a unique MAC avoids those hard to debug issues and makes the setup robust across different network environments.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_024.png" alt="Image: image_024"/></p> <h2 id="6-build-the-application-to-generate-the-elf"><strong>6. Build the application to generate the ELF.</strong></h2> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_025.png" alt="Image: image_025"/></p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_026.png" alt="Image: image_026"/></p> <h2 id="8open-the-uart-serial-monitor-115200-8n1-and-verify-startup-messages"><strong>8.Open the UART Serial Monitor (115200 8N1) and verify startup messages</strong></h2> <p>In Vitis, open Vitis -&gt; Serial Monitor and select the USB UART device for the board. In this project it appears as <code class="language-plaintext highlighter-rouge">/dev/ttyUSB0</code> (Silicon Labs), which you can recognize by the manufacturer string. Set 115200 baud, 8 data bits, no parity, 1 stop bit (<code class="language-plaintext highlighter-rouge">115200 8N1</code>), then open the connection so the terminal is listening. After the terminal is open, run the application in Vitis. The server banner and status prints should then appear in the Serial Monitor output as the program executes.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_027.png" alt="Image: image_027"/></p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_028.png" alt="Image: image_028"/></p> <h3 id="43-host-side-test-on-linux">4.3. Host side test on Linux</h3> <p>First confirm basic reachability using:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ping 192.168.1.10
</code></pre></div></div> <p>Then open a TCP session to the echo server using:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc <span class="nt">-v</span> 192.168.1.10 6001
</code></pre></div></div> <p>Type a short line of text. You should see the same text echoed back by the board.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_029.png" alt="Image: image_029"/></p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_030.png" alt="Image: image_030"/></p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_031.png" alt="Image: image_031"/></p> <h3 id="44-what-this-test-proves">4.4. What this test proves</h3> <p>A successful TCP echo session proves that:</p> <ol> <li>The PHY link is up and the MAC is transmitting and receiving frames through GEM0.</li> <li>The board IP configuration is correct for the local network.</li> <li>lwIP is receiving traffic, processing TCP, and transmitting replies correctly.</li> </ol> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_032.png" alt="Image: image_032"/></p> <h2 id="5-section-b-full-system-validation-using-the-udp-inverter-application">5. Section B: Full system validation using the UDP inverter application</h2> <h3 id="51-what-the-udp-inverter-service-validates">5.1. What the UDP inverter service validates</h3> <p>The UDP inverter service is the full system test. It validates Ethernet and lwIP UDP, and it validates PS to PL memory mapped register access in a deterministic loop.</p> <p>The host sends exactly 4 bytes representing a 32 bit word W in little endian order. The PS writes W to an AXI GPIO output register. In the PL, the output bus is bitwise inverted. The PS reads the inverted value R from an AXI GPIO input register and replies with 8 bytes containing W followed by R. The expected relationship is R equals bitwise NOT of W.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_033.png" alt="Image: image_033"/></p> <h3 id="52-udp-protocol-definition">5.2. UDP protocol definition</h3> <p>UDP port: <code class="language-plaintext highlighter-rouge">5005</code> Request payload: <code class="language-plaintext highlighter-rouge">4</code> bytes, little endian unsigned 32 bit word Response payload: <code class="language-plaintext highlighter-rouge">8</code> bytes, concatenation of W and R, in the same byte ordering Length check behavior: if the request is not exactly <code class="language-plaintext highlighter-rouge">4</code> bytes, the service replies with the ASCII string <code class="language-plaintext highlighter-rouge">BADLEN</code></p> <table style="width: 100%; border-collapse: collapse;"> <thead> <tr> <th style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;"><strong>Message</strong></th> <th style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;"><strong>Direction</strong></th> <th style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;"><strong>Length (bytes)</strong></th> <th style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;"><strong>Payload Format</strong></th> <th style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;"><strong>Notes</strong></th> </tr> </thead> <tbody> <tr> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">Request</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">Host -&gt; Board</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">4</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">W = 32-bit unsigned little-endian</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">Single word command</td> </tr> <tr> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">Response</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">Board -&gt; Host</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">8</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">W then R (both 32-bit, little-endian)</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">R = ~W</td> </tr> <tr> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">Error</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">Board -&gt; Host</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">8</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">ASCII "BADLEN"</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">Sent when request length != 4</td> </tr> </tbody> </table> <p>This response format is intentional. Returning both W and R allows the host to validate correctness without maintaining additional state. The host can confirm that the second word equals the bitwise inversion of the first word for each transaction.</p> <h3 id="53-build-and-run-steps-in-vitis">5.3. Build and run steps in Vitis</h3> <h4 id="1-create-a-platform-component-for-the-udp-inverter-import-the-same-xsa-as-in-the-tcp-section-and-ensure-lwip-is-enabled-and-the-bsp-dhcp-choice-is-set-as-intended-for-your-setup">1. Create a platform component for the UDP inverter (import the same XSA as in the TCP section) and ensure lwIP is enabled and the BSP DHCP choice is set as intended for your setup.</h4> <h4 id="2-create-an-application-component-from-your-udp-inverter-sources-and-select-the-udp-platform-component">2. Create an application component from your UDP inverter sources and select the UDP platform component.</h4> <h4 id="3-build-the-application-to-generate-the-elf">3. Build the application to generate the ELF.</h4> <h4 id="4-open-the-serial-monitor-115200-8n1-program-the-fpga-and-run-the-elf-on-ps7_cortexa9_0">4. Open the Serial Monitor (115200 8N1), program the FPGA, and run the ELF on <code class="language-plaintext highlighter-rouge">ps7_cortexa9_0</code>.</h4> <h4 id="5-confirm-on-uart-that-the-banner-prints-and-that-the-service-reports-it-is-listening-on-udp-port-5005">5. Confirm on UART that the banner prints and that the service reports it is listening on UDP port 5005.</h4> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_034.png" alt="Image: image_034"/></p> <h3 id="54-host-side-udp-test-python-client">5.4. Host side UDP test (Python client)</h3> <p>Start with a ping to confirm reachability:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ping 192.168.1.10
</code></pre></div></div> <p>Option A</p> <p>Open a terminal on the host PC and run the client script from the repository. Expected readback is the bitwise inversion. For example, <code class="language-plaintext highlighter-rouge">0x12345678</code> becomes <code class="language-plaintext highlighter-rouge">0xEDCBA987</code>.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ~/zc702-ps-ethernet-udp-gpio-inverter/host
python3 host_udp_inverter.py 192.168.1.10 0x12345678
</code></pre></div></div> <p>Option B:</p> <p>We can also test the UDP inverter using netcat with hexdump to see the raw bytes on the wire. This is an optional alternative to the Python client, but it is equally valid for confirming the protocol framing and end-to-end inversion:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="nt">-n</span> <span class="nt">-e</span> <span class="s1">'\x78\x56\x34\x12'</span> | nc <span class="nt">-u</span> <span class="nt">-w</span> 3 192.168.1.10 5005 | hexdump <span class="nt">-v</span> <span class="nt">-e</span> <span class="s1">'1/1 "%02x"'</span><span class="p">;</span> <span class="nb">echo</span>
</code></pre></div></div> <p>Although the board replies essentially immediately, nc -u -w 3 keeps the socket open until the timeout expires, so hexdump does not print the bytes until netcat closes. By contrast, a TCP nc session stays interactive and shows echoed data as soon as it arrives, which is why the TCP test feels instant while the UDP one appears slightly delayed.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_035.png" alt="Image: image_035"/></p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_036.png" alt="Image: image_036"/></p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-3-vitis-setup-and-testing/image_037.png" alt="Image: image_037"/></p> <h4 id="6-verification-summary">6. Verification Summary</h4> <p>The TCP echo baseline verifies the PS side network stack end to end: GEM0 link, IP configuration, lwIP initialization, and TCP receive and transmit behavior, without involving the PL.</p> <p>The UDP inverter test verifies the full system path: UDP reception, deterministic parsing, AXI Lite memory mapped writes and reads into the PL through AXI GPIO, and correct inversion on the PL datapath.</p> <p>Together, these two tests separate network bring up from PS to PL integration, so failures are localized and the overall bring up process stays repeatable.</p>]]></content><author><name></name></author><category term="zynq"/><category term="zc702"/><category term="ethernet"/><category term="lwip"/><category term="axi"/><category term="vivado"/><category term="vitis"/><category term="ps-pl"/><summary type="html"><![CDATA[This post covers the Vitis side of the ZC702 bring up. The goal is to validate Ethernet in two layers so that failures are diagnosable rather than ambiguous.]]></summary></entry><entry><title type="html">Post 1: ZC702 PS Ethernet over MIO and PS to PL AXI Loopback</title><link href="https://elsanousi2005.github.io/blog/2026/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/" rel="alternate" type="text/html" title="Post 1: ZC702 PS Ethernet over MIO and PS to PL AXI Loopback"/><published>2026-01-16T00:00:00+00:00</published><updated>2026-01-16T00:00:00+00:00</updated><id>https://elsanousi2005.github.io/blog/2026/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback</id><content type="html" xml:base="https://elsanousi2005.github.io/blog/2026/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/"><![CDATA[<p><strong>Author(s):</strong> Mostafa Elsanousi, <a href="https://github.com/muhammadfarhan720">Muhammad Farhan Azmine</a></p> <p><strong>Publication Date:</strong> 2026-01-16</p> <p><strong>Target Board:</strong> AMD/Xilinx ZC702 (xc7z020 Zynq-7000)<br/><strong>Toolchain:</strong> Vivado 2025.1, Vitis 2025.1<br/><strong>Keywords:</strong> Zynq, GEM0, Ethernet, MIO, RGMII, lwIP, UDP, AXI, AXI4-Lite, SmartConnect, GPIO</p> <h2 id="abstract">Abstract</h2> <p>This project demonstrates a complete, minimal, and repeatable Zynq 7000 bring up flow on the ZC702 board in which the Processing System handles Ethernet networking entirely within the hard silicon, while the Programmable Logic implements a deliberately simple datapath that can be exercised from software through memory mapped registers. The design uses GEM0 Ethernet over the ZC702 onboard RGMII connection to the PHY and RJ45 jack, then uses the PS to PL AXI general purpose port to write a 32 bit value into the fabric and read back a transformed result. The transformation is intentionally trivial, a bitwise inversion, so correctness is unambiguous. On the software side, two complementary applications validate the system: a standard lwIP TCP echo server that confirms the Ethernet stack is operational, and a custom lwIP UDP service that performs a deterministic command response exchange by writing to and reading from the AXI GPIO registers in the PL.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_002.png" alt="A block diagram of a Zynq-7000-based FPGA design showing AXI interconnect and GPIO path: - Processing System: &quot;processing_system7_0&quot; (ZYNQ7) with DDR and FIXED_IO pins to external memory/I/O; exposes M_AXI_GP0 and clocks/reset signals. - Reset/clock block: &quot;rst_ps7_0_50M&quot; providing slowest_sync_clk, mb_reset, ext_reset_in, aux_reset_in, dcm_locked and peripheral/reset outputs to the system. - AXI fabric: &quot;axi_interconnect_0&quot; (AXI Interconnect) with S00_AXI slave port and two master ports (M00_AXI, M01_AXI); connects the PS M_AXI_GP0 to peripherals. - Peripherals: - &quot;axi_gpio_in&quot;: AXI GPIO slave (S_AXI) providing gpio_io_i31:0 input signals. - &quot;axi_gpio_out&quot;: AXI GPIO slave (S_AXI) providing gpio_io_o31:0 output signals. - Logic/route: &quot;util_vector_logic_0&quot; (Utility Vector Logic) that takes Op131:0 and produces Res31:0, tying GPIO input to output logic. - Signal flow: PS -&gt; AXI Interconnect -&gt; AXI GPIO blocks -&gt; utility vector logic -&gt; feedback to GPIO; reset/clock nets from rst_ps7_0_50M feed the AXI and GPIO blocks. - External connections: DDR and FIXED_IO rails shown leaving the PS block. Overall the diagram shows a simple PS-driven AXI GPIO loopback/processing path with reset and clock management."/></p> <p><em>Figure 1: Full system block diagram showing PS Ethernet path and PS to PL register access path</em></p> <hr/> <h2 id="1-motivation-and-goals">1. Motivation and Goals</h2> <p>Zynq devices are most powerful when the boundary between software and hardware is treated as an interface you can reason about and verify. A common failure mode in early Zynq development is building a complex PL design before confirming that the basic fundamentals are correct: the PS boots reliably, Ethernet traffic reaches the board, the PS can access mapped PL peripherals, and resets and clocks are correctly applied to the fabric. This project is structured as a bring up and verification scaffold. It establishes a working Ethernet baseline on GEM0 and then proves a controlled PS to PL transaction path using AXI register reads and writes. If this minimal design works, later projects can safely replace the inverter datapath with more meaningful PL accelerators while reusing the same approach to software control and verification.</p> <p>The primary success criterion is simple: a host computer sends a 32 bit word to the board, the PS writes it into a PL register, the PL inverts it, the PS reads the result, and the board responds with both the original and the inverted values. A secondary success criterion is that a generic TCP echo server can accept a connection and mirror back arbitrary bytes, confirming that the Ethernet link, IP configuration, and lwIP processing loop are stable.</p> <hr/> <h2 id="2-system-architecture-and-responsibilities">2. System architecture and responsibilities</h2> <p>A Zynq 7000 device combines two worlds in one package. The Processing System contains the ARM cores, memory controllers, and hardened peripherals such as the Gigabit Ethernet MAC. The Programmable Logic is the FPGA fabric where custom datapaths and peripherals are implemented.</p> <p>In this project, the separation of responsibilities is intentional. The Processing System performs everything related to networking. It configures the Ethernet interface, runs lwIP, and implements application level protocols. The Programmable Logic performs only one operation: bitwise inversion of a 32 bit value. That operation is wrapped by two AXI GPIO peripherals so the PS can interact with it using ordinary memory mapped I/O.</p> <p>This architecture yields a clean mental model. If Ethernet fails, the issue is within PS configuration, PHY link, IP settings, or lwIP software. If Ethernet works but PL access fails, the issue is within clocks, resets, address mapping, bitstream programming, or AXI interconnect wiring. Because the PL datapath is trivial, functional ambiguity is removed.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xxl"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_005.png" alt="High-level block diagram of a hybrid PL/PS Ethernet system. - Left column - Programmable Logic (PL) - AXI SmartConnect - AXI GPIO OUT (address 0x4121_0000) - util_vector_logic (32-bit NOT) - AXI GPIO IN (address 0x4120_0000) - Dataflow: SmartConnect -&gt; GPIO OUT -&gt; 32-bit NOT -&gt; GPIO IN - Bottom-left - Host PC - Tools: Python UDP client / netcat / telnet - Connects to on-board GigE PHY - Right - Processing System (PS) - Onboard PHY links to GEM0 Ethernet MAC (PS via MIO pins 16..27, MDIO via MIO 52..53) - GEM0 feeds lwIP raw API stack - lwIP exposes two services: - TCP Echo Server on port 6001 - UDP Inverter Server on port 5005 - Arrows show Ethernet path: Host PC -&gt; On-board GigE PHY -&gt; GEM0 MAC -&gt; lwIP -&gt; application servers. GPIO path is internal to PL via AXI."/></p> <p><em>Figure 2A: PS/PL partitioning: networking in PS, 32-bit inverter datapath in PL with AXI GPIO wrappers</em></p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_006.png" alt="Diagram of a PS/PL network-to-MMIO data flow and echo/reply paths: - Left: Host PC &lt;-&gt; on-board GigE PHY -&gt; GEM0 MAC (PS) -&gt; lwIP stack (PS). - lwIP forwards packets to two PS apps: &quot;TCP echo (PS)&quot; (sends echoed bytes back to Host) and &quot;UDP inverter (PS)&quot;. - UDP inverter performs MMIO writes (label: &quot;MMIO write W&quot;) via M_AXI_GP0 (AXI4-Lite) into the PL interconnect (SmartConnect). - SmartConnect -&gt; AXI GPIO OUT at address 0x4121_0000 -&gt; a 32-bit NOT block -&gt; AXI GPIO IN at 0x4120_0000. - The PL GPIO read path returns data to the UDP inverter via MMIO read (label: &quot;MMIO read R&quot;); UDP inverter then replies to Host (label: &quot;Reply WR (8 bytes)&quot;). - Arrows indicate data flow: &quot;Echoes bytes&quot; from TCP echo back to Host; control/read/write MMIO labeled between PS and PL."/></p> <p><em>Figure 2B: End-to-end data flow: UDP/TCP traffic in PS and AXI-Lite MMIO to PL for [W][R] replies.</em></p> <hr/> <h2 id="3-ethernet-on-zc702-and-the-mac-to-phy-relationship">3. Ethernet on ZC702 and the MAC to PHY relationship</h2> <p>Ethernet on the ZC702 is implemented as a two chip partnership. The Zynq Processing System provides the MAC, which is responsible for framing, buffering, DMA style movement inside the PS, and presenting packets to software through a driver. The physical layer chip on the board provides the PHY, which is responsible for the analog signaling and the electrical interface to the cable through the RJ45 connector. The MAC and PHY communicate over a standardized digital interface. On the ZC702 that interface is RGMII for data and MDIO for management.</p> <p>This matters for the bring-up because you can conceptually split the Ethernet problem into two parts. Link status and auto negotiation involve the PHY and the management interface. Packet handling in lwIP involves the MAC driver and the software stack. A working system requires both pieces to be correctly wired and configured.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_008.png" alt="- A block-diagram of the Ethernet datapath between a Zynq-7000 Processing System (PS) and the ZC702 board PHY. - Left: &quot;Zynq-7000 Processing System (PS)&quot; block. - Center (inside PS): &quot;GEM0 Ethernet MAC&quot; performing framing, buffering and driver functions. - Right (on ZC702 board): &quot;GigE PHY&quot; (analog + line interface) connected onward to &quot;RJ45 + Magnetics&quot;. - Two labeled signal links between MAC and PHY: - RGMII data/clock (TX/RX) - bidirectional data and clock lines. - MDIO/MDC (management) - MDIO management interface."/></p> <p><em>Figure 3: Conceptual MAC to PHY diagram showing RGMII data signals and MDIO management channel</em></p> <hr/> <h2 id="4-digital-pin-routing-modes-in-zynq-mio-and-emio">4. Digital pin routing modes in Zynq: MIO and EMIO</h2> <p>A Zynq device offers two distinct ways to route PS peripheral signals to the outside world. Understanding this distinction is foundational for reliable board bring up, and it is especially important for Ethernet because the physical wiring on the board often dictates the correct choice.</p> <h3 id="41-what-mio-is">4.1. What MIO is</h3> <p>MIO stands for Multiplexed I/O. These are dedicated pins on the Zynq package that connect directly to hardened peripheral I/O inside the Processing System. When you route a PS peripheral through MIO, the signal path is strictly within the PS I/O subsystem and then out to the board pins. There is no dependence on the FPGA fabric for routing those peripheral signals. In practical terms, that means a MIO routed peripheral remains a PS native interface. It is configured through the PS configuration, and it does not require any PL logic to exist in order for the peripheral signals to reach the board.</p> <p>This mode is ideal when the board designer has already wired a peripheral, such as Ethernet or UART, directly to the Zynq MIO pins and expects the hardened peripheral to drive those pins.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_010.png" alt="- Top-level: large box labeled &quot;Processing System (PS)&quot;. - Inside PS, left box: &quot;Hardened PS Peripheral (e.g., GEM0 / UART)&quot;. - Inside PS, right box: &quot;MIO Pin Mux / PS I/O&quot;. - Arrow from the Hardened PS Peripheral to the MIO Pin Mux / PS I/O. - MIO Pin Mux / PS I/O arrows out to a separate box labeled &quot;Package Pins / Board Traces&quot;. - Separate boxed note below: &quot;No PL routing or logic required - PS peripheral drives pins directly&quot;, with a curved arrow pointing to the MIO Pin Mux. - Overall meaning: a PS peripheral connects through the PS MIO pin multiplexer directly to package/board pins without any PL (programmable logic) routing or additional logic."/></p> <p><em>Figure 4: Illustration of MIO routing showing a PS peripheral connected directly to package pins without traversing the PL</em></p> <h3 id="42-what-emio-is">4.2. What EMIO is</h3> <p>EMIO stands for Extended Multiplexed I/O. In this mode, the PS peripheral signals do not go directly to package pins. Instead, the PS exposes those signals internally to the Programmable Logic, and the PL then routes them through FPGA fabric resources to chosen external pins or to internal logic. EMIO is therefore a PS peripheral routed through the PL. It introduces flexibility, because the PL can remap or condition signals and can bring PS peripherals out to pins that are not part of the fixed MIO set. However, it also introduces dependency: the PL must be configured and clocked correctly for those peripheral signals to reach the outside world.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_011.png" alt="Diagram showing how a hardened PS peripheral is routed to external pins or PL logic via EMIO and PL routing: - Left box: Processing System (PS) - &quot;Hardened PS Peripheral&quot; -&gt; arrow to &quot;EMIO Interface&quot; - EMIO Interface output continues into the right box: Programmable Logic (PL) - Inside PL: &quot;PL Routing / Logic&quot; receives the EMIO signal - A separate input labeled &quot;Requires PL configuration + clocks&quot; feeds into the PL routing/logic - PL Routing / Logic -&gt; arrow to &quot;External Pins / Internal PL Logic&quot; (rightmost block) Overall: the PS peripheral uses the EMIO path into the PL, where configured PL routing/logic (and clocks/configuration) drive external pins or other PL logic."/></p> <p><em>Figure 5: Illustration of EMIO routing showing a PS peripheral passing through the PL before reaching external pins</em></p> <h3 id="43-why-ethernet-uses-mio-on-zc702-in-this-project">4.3. Why Ethernet uses MIO on ZC702 in this project</h3> <p>On the ZC702, the onboard Ethernet PHY is physically wired to the Zynq GEM0 interface using the board’s fixed routing. Because the RGMII and MDIO connections are already matched to the Processing System’s dedicated Ethernet capable pins, the most direct and robust configuration is to use GEM0 over MIO. This avoids unnecessary dependence on PL routing for the networking path and aligns with the board’s intended usage. It also results in a simpler failure surface during bring up: if the PS is running, the Ethernet pins are driven by the hardened peripheral, independent of any custom PL logic.</p> <p>EMIO Ethernet can be appropriate on other boards or designs, particularly when a PHY or external connector is routed to PL pins instead of PS pins, or when a design requires unusual pin mapping. In those cases, the Ethernet signals must be routed through the fabric. For the ZC702 onboard PHY path, MIO is the natural and tutorial friendly option.</p> <hr/> <h2 id="5-how-the-ps-communicates-with-the-pl-axi-gp-smartconnect-and-axi-lite">5. How the PS communicates with the PL: AXI GP, SmartConnect, and AXI-Lite</h2> <p>While Ethernet is kept entirely inside the PS, the purpose of the project is not only networking. The purpose is also to demonstrate a clean, software controlled PS to PL interface. In Zynq, that interface is typically AXI.</p> <h3 id="51-axi-lite-as-register-access">5.1. AXI Lite as register access</h3> <p>AXI is a family of bus protocols designed for high performance on chip communication. AXI Lite is a simplified subset intended for low bandwidth, memory mapped register interfaces. In practice, AXI Lite behaves like this: software running on the ARM writes a value to an address, and hardware in the PL interprets that write as a register update. Software then reads from another address, and hardware returns the current value of a register. This is exactly the semantics needed to control small peripherals such as GPIO blocks, control registers, and configuration interfaces.</p> <p>In this project, the PS uses a memory mapped master port called the AXI general purpose port. Through that port, the PS can access addresses that are decoded to PL peripherals. Because AXI Lite is register oriented, the software side can be extremely simple. It can use ordinary 32 bit memory mapped I/O operations to write data and set direction bits.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_013.png" alt="- A left-side ARM CPU (PS) block issues memory-mapped I/O (MMIO) 32-bit reads/writes. - Software is shown separately with the note &quot;Software sees registers as memory-mapped addresses&quot; and a dashed line to the MMIO block (software issues the MMIO accesses). - MMIO read/write goes to an &quot;AXI GP Master (AXI4-Lite)&quot; block. - The AXI master connects to an &quot;Address Decode&quot; block that maps addresses to PL registers. - The address-decode output goes to two PL register boxes: - &quot;PL Register Write (e.g., GPIO DATA/TRI)&quot; - writes from PS update PL registers. - &quot;PL Register Read (returns current value)&quot; - reads return the current PL register value back to software/PS (arrow returning along the bottom). - Overall the diagram shows the PS/software performing MMIO accesses over an AXI4-Lite GP master, an address decoder in PL selecting registers, and PL register read/write paths back to the CPU."/></p> <p><em>Figure 6: Conceptual diagram of an AXI Lite register transaction from software to a PL peripheral</em></p> <h3 id="52-why-smartconnect-exists">5.2. Why SmartConnect exists</h3> <p>The Programmable Logic design contains more than one AXI slave peripheral. There is an AXI GPIO block for the output register and an AXI GPIO block for the input register. The PS master port must be able to reach both. SmartConnect is the interconnect component that makes this clean. It provides address decoding and routing so that a single AXI master in the PS can access multiple AXI slave peripherals in the PL without manually constructing custom interconnect logic. In other words, SmartConnect acts as the switch fabric that connects the PS address space to multiple mapped peripherals.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_014.png" alt="A block-diagram screenshot of an AXI interconnect and two AXI GPIO peripherals. - Central component: &quot;smartconnect_0&quot; (AXI SmartConnect) with ports S00_AXI, M00_AXI, M01_AXI, aclk and aresetn. - Two peripheral blocks on the right: &quot;axi_gpio_out&quot; and &quot;axi_gpio_in&quot; (both labeled AXI GPIO). - Each AXI GPIO shows an S_AXI interface with signals s_axi_aclk and s_axi_aresetn, and a GPIO port gpio_io_i31:0 / gpio_io_o31:0. - Yellow-highlighted bus traces show AXI master/slave connections between smartconnect_0 and the two AXI GPIO blocks. - Black lines represent clock/reset routing between the SmartConnect and the GPIO blocks."/></p> <p><em>Figure 7: Vivado block design screenshot emphasizing PS AXI master to SmartConnect to two AXI GPIO slaves</em></p> <h3 id="53-clocks-and-resets-for-reliable-ps-to-pl-access">5.3. Clocks and resets for reliable PS to PL access</h3> <p>Memory mapped PL peripherals only respond correctly when the fabric clock domain is running and the AXI reset signals have been deasserted. This project intentionally uses a single fabric clock domain driven by the PS generated fabric clock at 50 MHz. That clock drives the AXI interconnect and both AXI GPIO peripherals. Reset is generated using the standard processor system reset block, which takes a PS provided reset input and produces synchronized active low reset outputs for the interconnect and peripherals. This separation matters because interconnect logic and endpoint peripherals can have different reset timing requirements, and a standard reset block ensures a clean deassertion sequence.</p> <hr/> <h2 id="6-the-pl-datapath-axi-gpio-out-to-inverter-to-axi-gpio-in">6. The PL datapath: AXI GPIO out to inverter to AXI GPIO in</h2> <p>The Programmable Logic portion of this design is a sanity datapath intended to be deterministic and easy to validate. Two AXI GPIO blocks expose registers to the Processing System. The output GPIO block presents a 32 bit value as a fabric signal. That signal is then passed through a vector logic block configured as a bitwise inversion. The inverted bus drives the input of the second GPIO block, allowing the PS to read the inverted value back through a different address.</p> <p>This design choice has two practical benefits. First, it isolates connectivity and address mapping issues. If the PS can write a word and read a different transformed word, then the AXI path, clocks, resets, address map, and peripheral configuration are all correct. Second, it provides a predictable transform. Inversion is both simple and high contrast. Any single bit error is visible, and common test patterns make failures immediately obvious.</p> <h3 id="61-the-register-interface-exposed-by-axi-gpio">6.1. The register interface exposed by AXI GPIO</h3> <p>AXI GPIO peripherals present a small set of registers. Two of the most important are the data register and the tri state direction register. The direction register controls whether each bit is treated as an input or an output. For the output GPIO block, the software configures the direction so that all bits are outputs. For the input GPIO block, the software configures the direction so that all bits are inputs. Once directions are configured, writing the data register updates the output bus, and reading the data register returns the sampled input bus. This is the mechanism by which the PS effectively controls and observes PL signals using memory mapped I/O. Vivado assigns each AXI GPIO a base address in the system map; in this design the IN block is at 0x4120_0000 and the OUT block is at 0x4121_0000 (Figure 8). Within each GPIO, software accesses registers by base + offset, where DATA = 0x0 and TRI = 0x4 (Figure 9).</p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_016.png" alt="The screenshot shows Xilinx Vivado (title bar: a project path and Vivado 2025.2) with the IP Integrator Block Design editor open and the Address Editor tab active. - Left pane: Flow Navigator (Project Manager, IP Integrator, Simulation, RTL Analysis, Synthesis, Implementation, Program &amp; Debug). - Main area: &quot;BLOCK DESIGN - design_1&quot; Address Editor showing Network 0 (/processing_system7_0/Data). - Two AXI GPIO slaves listed: /axi_gpio_in/S_AXI and /axi_gpio_out/S_AXI, both S_AXI, each with 64K range and base addresses 0x4120_0000 and 0x4121_0000 (high addresses 0x4120_FFFF and 0x4121_FFFF). - Top toolbar, write_bitstream status indicator (green check), and bottom tabs (Tcl Console, Messages, Log, Reports, Design Runs) visible."/></p> <p><em>Figure 8: Vivado Address Editor showing AXI GPIO base addresses (IN @ 0x4120_0000, OUT @ 0x4121_0000)</em></p> <table style="width: 100%; border-collapse: collapse;"> <thead> <tr> <th style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">Register</th> <th style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">Offset</th> <th style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">Access</th> <th style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">Meaning</th> </tr> </thead> <tbody> <tr> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">DATA</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">0x0</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">R/W</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">Read input bus or drive output bus</td> </tr> <tr> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">TRI</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">0x4</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">R/W</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">Direction bits (0 = output, 1 = input)</td> </tr> </tbody> </table> <p><em>Table 1: AXI GPIO register offsets used in software (DATA=0x0, TRI=0x4).</em></p> <hr/> <h2 id="7-end-to-end-network-validation-strategy">7. End to end network validation strategy</h2> <p>A bring up strategy benefits from having both a general sanity check and an application specific test. This project uses two complementary tests that serve different purposes.</p> <p>The first test is a standard lwIP TCP echo server example. It listens on a TCP port and echoes back whatever bytes arrive. Because TCP is connection oriented and stream based, this test is particularly convenient for interactive validation using common tools. If a host can connect, send characters, and see them echoed back, then the network link, IP configuration, and the lwIP processing loop are working end to end. This test is intentionally independent of the Programmable Logic, so it isolates Ethernet and lwIP.</p> <p>The second test is the project’s custom lwIP UDP inverter application. This test is not interactive text. It defines a small binary protocol. The host sends exactly four bytes representing a 32 bit word in little endian byte order. The board writes that word into the output GPIO register, reads the inverted value from the input GPIO register, and replies with eight bytes containing the original word followed by the readback word. If the host receives a response and the second word equals the bitwise inversion of the first, then PS to PL register access is verified alongside networking.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide-xl"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_018.png" alt="This is a block diagram of a ZC702-based networked PS/PL test setup showing TCP/UDP apps in the Zynq PS, an AXI-Lite MMIO path into PL GPIO logic, and host test clients. Key elements - Left: Zynq PS with GEM0 MAC + lwIP running: - TCP Echo Server (port 6001) - UDP Inverter App (port 5005) - Right: Zynq PL datapath: - AXI GPIO OUT -&gt; 32-bit NOT -&gt; AXI GPIO IN - PL readback returned to the UDP app via AXI-Lite read/write - Host PC (Linux): - TCP client (telnet / nc) to validate TCP echo (echoes same bytes) - UDP client (host_udp_inverter.py) sends little-endian 4-byte u32 datagrams; UDP app returns an 8-byte reply containing written and read data (WR) - Validation notes shown: - Basic: link, IP config, lwIP TCP loop (no PL access) - Full: networking + PS-PL AXI-Lite MMIO + PL inverter datapath Arrows indicate control/data flow: Ethernet -&gt; lwIP apps -&gt; AXI-Lite MMIO -&gt; PL GPIO inverter -&gt; readback -&gt; host replies."/></p> <p><em>Figure 9: Testing architecture diagram showing the TCP echo test and the UDP inverter test and what each validates</em></p> <hr/> <h2 id="8-tcp-and-udp-in-this-project-why-both-exist-and-what-each-proves">8. TCP and UDP in this project: why both exist and what each proves</h2> <p>TCP and UDP are often compared in abstract terms, but this project illustrates the difference through concrete implementations.</p> <p>TCP, as used in the echo server example, is connection oriented. The server binds to a port, transitions into a listening state, and accepts client connections. Once a connection exists, data is exchanged as a byte stream. There is no inherent message boundary in TCP. If a client sends ten bytes, the server might receive them as one chunk or multiple chunks depending on buffering, timing, and flow control. The echo example simply writes back whatever bytes were received. This makes TCP echo an excellent bring up test because it does not require a custom application framing protocol. Any payload, including plain text, can be used immediately.</p> <p>UDP, as used in the inverter application, is connectionless. The server binds to a port and receives discrete datagrams. Each datagram preserves message boundaries, which makes UDP convenient for fixed size command response exchanges. In this design, the datagram boundary is treated as the application message boundary. The server expects exactly four bytes and rejects anything else. When the correct payload length is received, the server executes a single deterministic transaction against the PL registers and returns a single deterministic response. This is a better fit than TCP for a register style command protocol because the message is naturally framed and the overhead is lower.</p> <p>The two tests therefore serve different purposes. The TCP echo server demonstrates that Ethernet and lwIP are operational in a way that is easy to reproduce with generic tools and arbitrary payloads. The UDP inverter demonstrates that networking and PS to PL register access are working together in a deterministic, verifiable control loop.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure-wide"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_020.png" alt="Top panel (UDP - datagrams) - Shows a client sending discrete datagrams (Datagram A, 4 bytes; Datagram B, 4 bytes) to an &quot;Inverter Server&quot;. - Server processes each datagram independently and sends a reply per datagram. - Emphasizes message boundaries: each UDP packet is a separate unit. Bottom panel (TCP - stream) - Shows a client connected to an &quot;Echo Server&quot; over a byte stream. - A labeled box reads &quot;Byte stream - no message boundaries&quot;. - Arrows indicate continuous, bidirectional flow: data is sent and echoed back, but message boundaries are not preserved. Overall point: UDP preserves per-datagram message boundaries with one reply per datagram; TCP provides a continuous byte stream without inherent message boundaries, so framing must be handled by the application."/></p> <p><em>Figure 10: Protocol comparison diagram showing TCP as a stream and UDP as message framed datagrams</em></p> <hr/> <h2 id="9-simulation-only-validation-of-the-axi-gpio-loopback">9. Simulation-Only Validation of the AXI GPIO Loopback</h2> <p>To validate the PL inverter without hardware, I built a simulation-only block design. The AXI VIP acts as a stand-in for the PS, issuing AXI-Lite reads and writes. Those transactions pass through SmartConnect and reach two AXI GPIO blocks – one configured as output and one as input – with a 32-bit NOT between them. I exported the clock and reset as external ports (clk_in1_0, ext_reset_in_0) so the testbench could drive them directly. The proc_sys_reset and clocking wizard provide a realistic reset/clock environment, while the VIP gives full control of addresses and data from the testbench. This makes the simulation faithful to real AXI behavior but still simple and self-contained for regression testing. It should be noted that I configured the Clocking Wizard IP block reset to be active low as it is set to active high by default.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_022.png" alt="This is a Vivado-style block diagram of an AXI-based embedded design. Key elements: - Left: external inputs - clk_in1_0 and ext_reset_in_0 feed clk_wiz_0 (Clocking Wizard) producing clk_out1 and locked. - proc_sys_reset_0 (Processor System Reset) takes the clocks and reset inputs and produces various resets (mb_reset, bus_struct_reset, peripheral_reset, interconnect_aresetn, peripheral_aresetn). - Center: AXI master and interconnect - axi_vip_0 (AXI Verification IP) as an AXI master (M_AXI) connected to smartconnect_0. - smartconnect_0 (AXI SmartConnect) routes AXI transactions between the master and AXI peripherals. - Right: AXI peripherals and logic - Two AXI GPIO blocks: axi_gpio_in and axi_gpio_out connected as AXI slaves to the SmartConnect. - A utility block util_vector_logic_0 (labelled &quot;Discontinued&quot;) performing vector logic on the GPIO outputs; its Res31:0 driven by the GPIO outputs (Op31:0). - AXI control signals (S_AXI/M_AXI, aclk, aresetn, gpio_io_o/gpio_io_i) interconnect the modules; reset/clock nets from proc_sys_reset_0 and clk_wiz_0 are distributed to the AXI IPs."/></p> <p><em>Figure 11: Simulation-only block design for AXI-Lite verification (AXI VIP -&gt; SmartConnect -&gt; AXI GPIO IN/OUT with inverter)</em></p> <p>A 100 MHz clock is generated in the testbench (always #5 clk_in1 = ~clk_in1;), and reset is asserted low for several cycles before being released. Once reset deasserts, the AXI VIP master issues a sequence of AXI-Lite writes to the GPIO OUT base address (0x4121_0000) and immediately reads back from the GPIO IN base address (0x4120_0000). Each read is checked against the expected inverted value using a small pass/fail scoreboard inside the do_one() task. Test vectors cover a mix of corner cases and patterns as seen in the table below.</p> <table style="width: 100%; border-collapse: collapse;"> <thead> <tr> <th style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">Write (W)</th> <th style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">Expected Read (R = ~W)</th> </tr> </thead> <tbody> <tr> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">0x00000000</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">0xFFFFFFFF</td> </tr> <tr> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">0xFFFFFFFF</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">0x00000000</td> </tr> <tr> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">0x12345678</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">0xEDCBA987</td> </tr> <tr> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">0xA5A5A5A5</td> <td style="border: 1px solid #d0d0d0; padding: 8px; text-align: center;">0x5A5A5A5A</td> </tr> </tbody> </table> <p><em>Table 2: AXI GPIO inverter test vectors and expected readback</em></p> <p>On a successful run, the TCL console shows PASS messages for each vector followed by $finish, confirming that the AXI GPIO write/read path and the PL inverter are both functioning as seen in the figure below.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_023.png" alt="Screenshot of Xilinx Vivado (2025.2) showing a simulation workspace. Key visible items: - Left pane: Flow Navigator with sections like Project Manager, IP Integrator, Simulation, RTL Analysis, Synthesis, Implementation, Program and Debug. - Center-left: Sources/Hierarchy panel listing design files (axi_gpio_tb_wrapper, design_1_wrapper) and Simulation Sources (tb_axi_gpio_tb.sv). - Center-top: Main toolbar and simulation controls; simulation mode indicated as &quot;SIMULATION - Behavioral Simulation - Functional - sim_1&quot;. - Center-right: Text editor open on tb_axi_gpio_tb.sv (SystemVerilog testbench) with a highlighted line and visible code for driving and checking AXI GPIO transfers. - Bottom: Tcl Console / Messages pane showing simulation output lines like &quot;PASS: wrote 00000000 read ffffffff&quot;, several PASS messages, and a finish message with simulation time and file/line reference. - Right-top status: &quot;Synthesis and Implementation Out-of-date&quot; indicator."/></p> <p><em>Figure 12: XSim TCL console showing AXI-VIP PASS messages and end-of-simulation checks</em></p> <p>Figure 13 highlights the key AXI-Lite signals from the VIP master. clk_in1 is the 100MHz testbench clock; ext_reset is the active-low reset driven by the testbench; aclk is the AXI clock inside the BD (from the clocking wizard). m_axi_wdata[31:0] is the data written to GPIO OUT, m_axi_araddr[31:0] is the read address for GPIO IN, and m_axi_rdata[31:0] is the returned read data. resp[1:0] shows the AXI response code for each transaction, and rdata[31:0] is the testbench’s captured readback used in the comparison check.</p> <p class="img-fluid rounded z-depth-1 d-block post-figure"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_024.png" alt="- Screenshot of a digital waveform viewer (testbench file name shown: tb_axi_gpio_tb_behav.wcfg). - Left column: signal list and current hex values (clk_in1, ext_reset, resp1:0, rdata31:0, aclk, m_axi_araddr31:0, m_axi_wdata31:0, m_axi_rdata31:0, etc.). - Main pane: time axis in nanoseconds (0 -&gt; 4,610,000 ns) and vertical grid lines. - Waveforms: clock signals (green) toggling, reset and response lines, and several bus traces shown as green/red waveforms with annotated data values like 5a5a5a5a, xxxxxxxx, ffffffff, 00000000, edcba987. - Typical viewer UI elements: zoom/toolbar at top, signal-value column between list and waveform."/></p> <p><em>Figure 13: Behavioral simulation waveform showing AXI-Lite writes to GPIO OUT and reads from GPIO IN returning the inverted data.</em></p> <hr/> <h2 id="10-summary-and-transition-to-implementation-details">10. Summary and transition to implementation details</h2> <p>This system overview established the key architectural decisions behind the project. Ethernet is implemented using GEM0 over MIO because the ZC702 board routes the onboard PHY to the Processing System’s dedicated Ethernet interface. The Programmable Logic exists to provide a minimal, deterministic datapath that can be exercised through memory mapped AXI Lite register accesses. The PS reaches the PL through the AXI general purpose port and an AXI interconnect, and two AXI GPIO peripherals expose a simple register interface for write and readback. Finally, validation is performed in two layers: a generic TCP echo server test to confirm the network stack, and a custom UDP inverter protocol to confirm the combined networking and PS to PL control path.</p> <p>The next post will focus on the hardware construction in Vivado. It will walk through the Processing System configuration for GEM0, the block design composition, address mapping, clock and reset wiring, bitstream generation, and XSA export for Vitis.</p>]]></content><author><name></name></author><category term="zynq"/><category term="zc702"/><category term="ethernet"/><category term="lwip"/><category term="axi"/><category term="vivado"/><category term="vitis"/><category term="ps-pl"/><summary type="html"><![CDATA[Minimal Zynq-7000 bring-up on ZC702 using PS GEM0 Ethernet and a simple PS-to-PL AXI loopback.]]></summary></entry></feed>