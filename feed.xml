<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://elsanousi2005.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://elsanousi2005.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2026-01-17T20:29:22+00:00</updated><id>https://elsanousi2005.github.io/feed.xml</id><title type="html">Mostafa Elsanousi</title><subtitle>Computer Engineering student at Virginia Tech focused on embedded systems, FPGA/SoC design, and chip-scale integration. Documenting projects, bring-up notes, and engineering writeups. </subtitle><entry><title type="html">Post 1: ZC702 PS Ethernet over MIO and PS to PL AXI Loopback</title><link href="https://elsanousi2005.github.io/blog/2026/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/" rel="alternate" type="text/html" title="Post 1: ZC702 PS Ethernet over MIO and PS to PL AXI Loopback"/><published>2026-01-16T00:00:00+00:00</published><updated>2026-01-16T00:00:00+00:00</updated><id>https://elsanousi2005.github.io/blog/2026/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback</id><content type="html" xml:base="https://elsanousi2005.github.io/blog/2026/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/"><![CDATA[<p><strong>Author(s):</strong> Mostafa Elsanousi, <a href="https://github.com/muhammadfarhan720">Muhammad Farhan Azmine</a></p> <p><strong>Publication Date:</strong> 2026-01-16</p> <p><strong>Target Board:</strong> AMD/Xilinx ZC702 (xc7z020 Zynq-7000)<br/><strong>Toolchain:</strong> Vivado 2025.1, Vitis 2025.1<br/><strong>Keywords:</strong> Zynq, GEM0, Ethernet, MIO, RGMII, lwIP, UDP, AXI, AXI4-Lite, SmartConnect, GPIO</p> <h2 id="abstract">Abstract</h2> <p>This project demonstrates a complete, minimal, and repeatable Zynq 7000 bring up flow on the ZC702 board in which the Processing System handles Ethernet networking entirely within the hard silicon, while the Programmable Logic implements a deliberately simple datapath that can be exercised from software through memory mapped registers. The design uses GEM0 Ethernet over the ZC702 onboard RGMII connection to the PHY and RJ45 jack, then uses the PS to PL AXI general purpose port to write a 32 bit value into the fabric and read back a transformed result. The transformation is intentionally trivial, a bitwise inversion, so correctness is unambiguous. On the software side, two complementary applications validate the system: a standard lwIP TCP echo server that confirms the Ethernet stack is operational, and a custom lwIP UDP service that performs a deterministic command response exchange by writing to and reading from the AXI GPIO registers in the PL.</p> <p class="img-fluid rounded z-depth-1 mx-auto d-block" style="width: 100%; max-width: 700px;"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_002.png" alt="A block diagram of a Zynq-7000-based FPGA design showing AXI interconnect and GPIO path: - Processing System: &quot;processing_system7_0&quot; (ZYNQ7) with DDR and FIXED_IO pins to external memory/I/O; exposes M_AXI_GP0 and clocks/reset signals. - Reset/clock block: &quot;rst_ps7_0_50M&quot; providing slowest_sync_clk, mb_reset, ext_reset_in, aux_reset_in, dcm_locked and peripheral/reset outputs to the system. - AXI fabric: &quot;axi_interconnect_0&quot; (AXI Interconnect) with S00_AXI slave port and two master ports (M00_AXI, M01_AXI); connects the PS M_AXI_GP0 to peripherals. - Peripherals: - &quot;axi_gpio_in&quot;: AXI GPIO slave (S_AXI) providing gpio_io_i31:0 input signals. - &quot;axi_gpio_out&quot;: AXI GPIO slave (S_AXI) providing gpio_io_o31:0 output signals. - Logic/route: &quot;util_vector_logic_0&quot; (Utility Vector Logic) that takes Op131:0 and produces Res31:0, tying GPIO input to output logic. - Signal flow: PS -&gt; AXI Interconnect -&gt; AXI GPIO blocks -&gt; utility vector logic -&gt; feedback to GPIO; reset/clock nets from rst_ps7_0_50M feed the AXI and GPIO blocks. - External connections: DDR and FIXED_IO rails shown leaving the PS block. Overall the diagram shows a simple PS-driven AXI GPIO loopback/processing path with reset and clock management."/></p> <p><em>Figure 1: Full system block diagram showing PS Ethernet path and PS to PL register access path</em></p> <hr/> <h2 id="1-motivation-and-goals">1. Motivation and Goals</h2> <p>Zynq devices are most powerful when the boundary between software and hardware is treated as an interface you can reason about and verify. A common failure mode in early Zynq development is building a complex PL design before confirming that the basic fundamentals are correct: the PS boots reliably, Ethernet traffic reaches the board, the PS can access mapped PL peripherals, and resets and clocks are correctly applied to the fabric. This project is structured as a bring up and verification scaffold. It establishes a working Ethernet baseline on GEM0 and then proves a controlled PS to PL transaction path using AXI register reads and writes. If this minimal design works, later projects can safely replace the inverter datapath with more meaningful PL accelerators while reusing the same approach to software control and verification.</p> <p>The primary success criterion is simple: a host computer sends a 32 bit word to the board, the PS writes it into a PL register, the PL inverts it, the PS reads the result, and the board responds with both the original and the inverted values. A secondary success criterion is that a generic TCP echo server can accept a connection and mirror back arbitrary bytes, confirming that the Ethernet link, IP configuration, and lwIP processing loop are stable.</p> <hr/> <h2 id="2-system-architecture-and-responsibilities">2. System architecture and responsibilities</h2> <p>A Zynq 7000 device combines two worlds in one package. The Processing System contains the ARM cores, memory controllers, and hardened peripherals such as the Gigabit Ethernet MAC. The Programmable Logic is the FPGA fabric where custom datapaths and peripherals are implemented.</p> <p>In this project, the separation of responsibilities is intentional. The Processing System performs everything related to networking. It configures the Ethernet interface, runs lwIP, and implements application level protocols. The Programmable Logic performs only one operation: bitwise inversion of a 32 bit value. That operation is wrapped by two AXI GPIO peripherals so the PS can interact with it using ordinary memory mapped I/O.</p> <p>This architecture yields a clean mental model. If Ethernet fails, the issue is within PS configuration, PHY link, IP settings, or lwIP software. If Ethernet works but PL access fails, the issue is within clocks, resets, address mapping, bitstream programming, or AXI interconnect wiring. Because the PL datapath is trivial, functional ambiguity is removed.</p> <p class="img-fluid rounded z-depth-1 mx-auto d-block" style="width: 100%; max-width: 700px;"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_005.png" alt="High-level block diagram of a hybrid PL/PS Ethernet system. - Left column - Programmable Logic (PL) - AXI SmartConnect - AXI GPIO OUT (address 0x4121_0000) - util_vector_logic (32-bit NOT) - AXI GPIO IN (address 0x4120_0000) - Dataflow: SmartConnect -&gt; GPIO OUT -&gt; 32-bit NOT -&gt; GPIO IN - Bottom-left - Host PC - Tools: Python UDP client / netcat / telnet - Connects to on-board GigE PHY - Right - Processing System (PS) - Onboard PHY links to GEM0 Ethernet MAC (PS via MIO pins 16..27, MDIO via MIO 52..53) - GEM0 feeds lwIP raw API stack - lwIP exposes two services: - TCP Echo Server on port 6001 - UDP Inverter Server on port 5005 - Arrows show Ethernet path: Host PC -&gt; On-board GigE PHY -&gt; GEM0 MAC -&gt; lwIP -&gt; application servers. GPIO path is internal to PL via AXI."/></p> <p><em>Figure 2A: PS/PL partitioning: networking in PS, 32-bit inverter datapath in PL with AXI GPIO wrappers</em></p> <p class="img-fluid rounded z-depth-1 mx-auto d-block" style="width: 100%; max-width: 700px;"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_006.png" alt="Diagram of a PS/PL network-to-MMIO data flow and echo/reply paths: - Left: Host PC &lt;-&gt; on-board GigE PHY -&gt; GEM0 MAC (PS) -&gt; lwIP stack (PS). - lwIP forwards packets to two PS apps: &quot;TCP echo (PS)&quot; (sends echoed bytes back to Host) and &quot;UDP inverter (PS)&quot;. - UDP inverter performs MMIO writes (label: &quot;MMIO write W&quot;) via M_AXI_GP0 (AXI4-Lite) into the PL interconnect (SmartConnect). - SmartConnect -&gt; AXI GPIO OUT at address 0x4121_0000 -&gt; a 32-bit NOT block -&gt; AXI GPIO IN at 0x4120_0000. - The PL GPIO read path returns data to the UDP inverter via MMIO read (label: &quot;MMIO read R&quot;); UDP inverter then replies to Host (label: &quot;Reply WR (8 bytes)&quot;). - Arrows indicate data flow: &quot;Echoes bytes&quot; from TCP echo back to Host; control/read/write MMIO labeled between PS and PL."/></p> <p><em>Figure 2B: End-to-end data flow: UDP/TCP traffic in PS and AXI-Lite MMIO to PL for [W][R] replies.</em></p> <hr/> <h2 id="3-ethernet-on-zc702-and-the-mac-to-phy-relationship">3. Ethernet on ZC702 and the MAC to PHY relationship</h2> <p>Ethernet on the ZC702 is implemented as a two chip partnership. The Zynq Processing System provides the MAC, which is responsible for framing, buffering, DMA style movement inside the PS, and presenting packets to software through a driver. The physical layer chip on the board provides the PHY, which is responsible for the analog signaling and the electrical interface to the cable through the RJ45 connector. The MAC and PHY communicate over a standardized digital interface. On the ZC702 that interface is RGMII for data and MDIO for management.</p> <p>This matters for the bring-up because you can conceptually split the Ethernet problem into two parts. Link status and auto negotiation involve the PHY and the management interface. Packet handling in lwIP involves the MAC driver and the software stack. A working system requires both pieces to be correctly wired and configured.</p> <p class="img-fluid rounded z-depth-1 mx-auto d-block" style="width: 100%; max-width: 700px;"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_008.png" alt="- A block-diagram of the Ethernet datapath between a Zynq-7000 Processing System (PS) and the ZC702 board PHY. - Left: &quot;Zynq-7000 Processing System (PS)&quot; block. - Center (inside PS): &quot;GEM0 Ethernet MAC&quot; performing framing, buffering and driver functions. - Right (on ZC702 board): &quot;GigE PHY&quot; (analog + line interface) connected onward to &quot;RJ45 + Magnetics&quot;. - Two labeled signal links between MAC and PHY: - RGMII data/clock (TX/RX) - bidirectional data and clock lines. - MDIO/MDC (management) - MDIO management interface."/></p> <p><em>Figure 3: Conceptual MAC to PHY diagram showing RGMII data signals and MDIO management channel</em></p> <hr/> <h2 id="4-digital-pin-routing-modes-in-zynq-mio-and-emio">4. Digital pin routing modes in Zynq: MIO and EMIO</h2> <p>A Zynq device offers two distinct ways to route PS peripheral signals to the outside world. Understanding this distinction is foundational for reliable board bring up, and it is especially important for Ethernet because the physical wiring on the board often dictates the correct choice.</p> <h3 id="41-what-mio-is">4.1. What MIO is</h3> <p>MIO stands for Multiplexed I/O. These are dedicated pins on the Zynq package that connect directly to hardened peripheral I/O inside the Processing System. When you route a PS peripheral through MIO, the signal path is strictly within the PS I/O subsystem and then out to the board pins. There is no dependence on the FPGA fabric for routing those peripheral signals. In practical terms, that means a MIO routed peripheral remains a PS native interface. It is configured through the PS configuration, and it does not require any PL logic to exist in order for the peripheral signals to reach the board.</p> <p>This mode is ideal when the board designer has already wired a peripheral, such as Ethernet or UART, directly to the Zynq MIO pins and expects the hardened peripheral to drive those pins.</p> <p class="img-fluid rounded z-depth-1 mx-auto d-block" style="width: 100%; max-width: 700px;"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_010.png" alt="- Top-level: large box labeled &quot;Processing System (PS)&quot;. - Inside PS, left box: &quot;Hardened PS Peripheral (e.g., GEM0 / UART)&quot;. - Inside PS, right box: &quot;MIO Pin Mux / PS I/O&quot;. - Arrow from the Hardened PS Peripheral to the MIO Pin Mux / PS I/O. - MIO Pin Mux / PS I/O arrows out to a separate box labeled &quot;Package Pins / Board Traces&quot;. - Separate boxed note below: &quot;No PL routing or logic required - PS peripheral drives pins directly&quot;, with a curved arrow pointing to the MIO Pin Mux. - Overall meaning: a PS peripheral connects through the PS MIO pin multiplexer directly to package/board pins without any PL (programmable logic) routing or additional logic."/></p> <p><em>Figure 4: Illustration of MIO routing showing a PS peripheral connected directly to package pins without traversing the PL</em></p> <h3 id="42-what-emio-is">4.2. What EMIO is</h3> <p>EMIO stands for Extended Multiplexed I/O. In this mode, the PS peripheral signals do not go directly to package pins. Instead, the PS exposes those signals internally to the Programmable Logic, and the PL then routes them through FPGA fabric resources to chosen external pins or to internal logic. EMIO is therefore a PS peripheral routed through the PL. It introduces flexibility, because the PL can remap or condition signals and can bring PS peripherals out to pins that are not part of the fixed MIO set. However, it also introduces dependency: the PL must be configured and clocked correctly for those peripheral signals to reach the outside world.</p> <p class="img-fluid rounded z-depth-1 mx-auto d-block" style="width: 100%; max-width: 700px;"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_011.png" alt="Diagram showing how a hardened PS peripheral is routed to external pins or PL logic via EMIO and PL routing: - Left box: Processing System (PS) - &quot;Hardened PS Peripheral&quot; -&gt; arrow to &quot;EMIO Interface&quot; - EMIO Interface output continues into the right box: Programmable Logic (PL) - Inside PL: &quot;PL Routing / Logic&quot; receives the EMIO signal - A separate input labeled &quot;Requires PL configuration + clocks&quot; feeds into the PL routing/logic - PL Routing / Logic -&gt; arrow to &quot;External Pins / Internal PL Logic&quot; (rightmost block) Overall: the PS peripheral uses the EMIO path into the PL, where configured PL routing/logic (and clocks/configuration) drive external pins or other PL logic."/></p> <p><em>Figure 5: Illustration of EMIO routing showing a PS peripheral passing through the PL before reaching external pins</em></p> <h3 id="43-why-ethernet-uses-mio-on-zc702-in-this-project">4.3. Why Ethernet uses MIO on ZC702 in this project</h3> <p>On the ZC702, the onboard Ethernet PHY is physically wired to the Zynq GEM0 interface using the board’s fixed routing. Because the RGMII and MDIO connections are already matched to the Processing System’s dedicated Ethernet capable pins, the most direct and robust configuration is to use GEM0 over MIO. This avoids unnecessary dependence on PL routing for the networking path and aligns with the board’s intended usage. It also results in a simpler failure surface during bring up: if the PS is running, the Ethernet pins are driven by the hardened peripheral, independent of any custom PL logic.</p> <p>EMIO Ethernet can be appropriate on other boards or designs, particularly when a PHY or external connector is routed to PL pins instead of PS pins, or when a design requires unusual pin mapping. In those cases, the Ethernet signals must be routed through the fabric. For the ZC702 onboard PHY path, MIO is the natural and tutorial friendly option.</p> <hr/> <h2 id="5-how-the-ps-communicates-with-the-pl-axi-gp-smartconnect-and-axi-lite">5. How the PS communicates with the PL: AXI GP, SmartConnect, and AXI-Lite</h2> <p>While Ethernet is kept entirely inside the PS, the purpose of the project is not only networking. The purpose is also to demonstrate a clean, software controlled PS to PL interface. In Zynq, that interface is typically AXI.</p> <h3 id="51-axi-lite-as-register-access">5.1. AXI Lite as register access</h3> <p>AXI is a family of bus protocols designed for high performance on chip communication. AXI Lite is a simplified subset intended for low bandwidth, memory mapped register interfaces. In practice, AXI Lite behaves like this: software running on the ARM writes a value to an address, and hardware in the PL interprets that write as a register update. Software then reads from another address, and hardware returns the current value of a register. This is exactly the semantics needed to control small peripherals such as GPIO blocks, control registers, and configuration interfaces.</p> <p>In this project, the PS uses a memory mapped master port called the AXI general purpose port. Through that port, the PS can access addresses that are decoded to PL peripherals. Because AXI Lite is register oriented, the software side can be extremely simple. It can use ordinary 32 bit memory mapped I/O operations to write data and set direction bits.</p> <p class="img-fluid rounded z-depth-1 mx-auto d-block" style="width: 100%; max-width: 700px;"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_013.png" alt="- A left-side ARM CPU (PS) block issues memory-mapped I/O (MMIO) 32-bit reads/writes. - Software is shown separately with the note &quot;Software sees registers as memory-mapped addresses&quot; and a dashed line to the MMIO block (software issues the MMIO accesses). - MMIO read/write goes to an &quot;AXI GP Master (AXI4-Lite)&quot; block. - The AXI master connects to an &quot;Address Decode&quot; block that maps addresses to PL registers. - The address-decode output goes to two PL register boxes: - &quot;PL Register Write (e.g., GPIO DATA/TRI)&quot; - writes from PS update PL registers. - &quot;PL Register Read (returns current value)&quot; - reads return the current PL register value back to software/PS (arrow returning along the bottom). - Overall the diagram shows the PS/software performing MMIO accesses over an AXI4-Lite GP master, an address decoder in PL selecting registers, and PL register read/write paths back to the CPU."/></p> <p><em>Figure 6: Conceptual diagram of an AXI Lite register transaction from software to a PL peripheral</em></p> <h3 id="52-why-smartconnect-exists">5.2. Why SmartConnect exists</h3> <p>The Programmable Logic design contains more than one AXI slave peripheral. There is an AXI GPIO block for the output register and an AXI GPIO block for the input register. The PS master port must be able to reach both. SmartConnect is the interconnect component that makes this clean. It provides address decoding and routing so that a single AXI master in the PS can access multiple AXI slave peripherals in the PL without manually constructing custom interconnect logic. In other words, SmartConnect acts as the switch fabric that connects the PS address space to multiple mapped peripherals.</p> <p class="img-fluid rounded z-depth-1 mx-auto d-block" style="width: 100%; max-width: 700px;"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_014.png" alt="A block-diagram screenshot of an AXI interconnect and two AXI GPIO peripherals. - Central component: &quot;smartconnect_0&quot; (AXI SmartConnect) with ports S00_AXI, M00_AXI, M01_AXI, aclk and aresetn. - Two peripheral blocks on the right: &quot;axi_gpio_out&quot; and &quot;axi_gpio_in&quot; (both labeled AXI GPIO). - Each AXI GPIO shows an S_AXI interface with signals s_axi_aclk and s_axi_aresetn, and a GPIO port gpio_io_i31:0 / gpio_io_o31:0. - Yellow-highlighted bus traces show AXI master/slave connections between smartconnect_0 and the two AXI GPIO blocks. - Black lines represent clock/reset routing between the SmartConnect and the GPIO blocks."/></p> <p><em>Figure 7: Vivado block design screenshot emphasizing PS AXI master to SmartConnect to two AXI GPIO slaves</em></p> <h3 id="53-clocks-and-resets-for-reliable-ps-to-pl-access">5.3. Clocks and resets for reliable PS to PL access</h3> <p>Memory mapped PL peripherals only respond correctly when the fabric clock domain is running and the AXI reset signals have been deasserted. This project intentionally uses a single fabric clock domain driven by the PS generated fabric clock at 50 MHz. That clock drives the AXI interconnect and both AXI GPIO peripherals. Reset is generated using the standard processor system reset block, which takes a PS provided reset input and produces synchronized active low reset outputs for the interconnect and peripherals. This separation matters because interconnect logic and endpoint peripherals can have different reset timing requirements, and a standard reset block ensures a clean deassertion sequence.</p> <hr/> <h2 id="6-the-pl-datapath-axi-gpio-out-to-inverter-to-axi-gpio-in">6. The PL datapath: AXI GPIO out to inverter to AXI GPIO in</h2> <p>The Programmable Logic portion of this design is a sanity datapath intended to be deterministic and easy to validate. Two AXI GPIO blocks expose registers to the Processing System. The output GPIO block presents a 32 bit value as a fabric signal. That signal is then passed through a vector logic block configured as a bitwise inversion. The inverted bus drives the input of the second GPIO block, allowing the PS to read the inverted value back through a different address.</p> <p>This design choice has two practical benefits. First, it isolates connectivity and address mapping issues. If the PS can write a word and read a different transformed word, then the AXI path, clocks, resets, address map, and peripheral configuration are all correct. Second, it provides a predictable transform. Inversion is both simple and high contrast. Any single bit error is visible, and common test patterns make failures immediately obvious.</p> <h3 id="61-the-register-interface-exposed-by-axi-gpio">6.1. The register interface exposed by AXI GPIO</h3> <p>AXI GPIO peripherals present a small set of registers. Two of the most important are the data register and the tri state direction register. The direction register controls whether each bit is treated as an input or an output. For the output GPIO block, the software configures the direction so that all bits are outputs. For the input GPIO block, the software configures the direction so that all bits are inputs. Once directions are configured, writing the data register updates the output bus, and reading the data register returns the sampled input bus. This is the mechanism by which the PS effectively controls and observes PL signals using memory mapped I/O. Vivado assigns each AXI GPIO a base address in the system map; in this design the IN block is at 0x4120_0000 and the OUT block is at 0x4121_0000 (Figure 8). Within each GPIO, software accesses registers by base + offset, where DATA = 0x0 and TRI = 0x4 (Figure 9).</p> <p class="img-fluid rounded z-depth-1 mx-auto d-block" style="width: 100%; max-width: 700px;"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_016.png" alt="The screenshot shows Xilinx Vivado (title bar: a project path and Vivado 2025.2) with the IP Integrator Block Design editor open and the Address Editor tab active. - Left pane: Flow Navigator (Project Manager, IP Integrator, Simulation, RTL Analysis, Synthesis, Implementation, Program &amp; Debug). - Main area: &quot;BLOCK DESIGN - design_1&quot; Address Editor showing Network 0 (/processing_system7_0/Data). - Two AXI GPIO slaves listed: /axi_gpio_in/S_AXI and /axi_gpio_out/S_AXI, both S_AXI, each with 64K range and base addresses 0x4120_0000 and 0x4121_0000 (high addresses 0x4120_FFFF and 0x4121_FFFF). - Top toolbar, write_bitstream status indicator (green check), and bottom tabs (Tcl Console, Messages, Log, Reports, Design Runs) visible."/></p> <p><em>Figure 8: Vivado Address Editor showing AXI GPIO base addresses (IN @ 0x4120_0000, OUT @ 0x4121_0000)</em></p> <table> <thead> <tr> <th style="text-align: center"><strong>Register</strong></th> <th style="text-align: center"><strong>Offset</strong></th> <th style="text-align: center"><strong>Access</strong></th> <th style="text-align: center"><strong>Meaning</strong></th> </tr> </thead> <tbody> <tr> <td style="text-align: center"><strong>DATA</strong></td> <td style="text-align: center">0x0</td> <td style="text-align: center">R/W</td> <td style="text-align: center">Read input bus or drive output bus</td> </tr> <tr> <td style="text-align: center"><strong>TRI</strong></td> <td style="text-align: center">0x4</td> <td style="text-align: center">R/W</td> <td style="text-align: center">Direction bits (0 = output, 1 = input)</td> </tr> </tbody> </table> <p><em>Table 1: AXI GPIO register offsets used in software (DATA=0x0, TRI=0x4).</em></p> <hr/> <h2 id="7-end-to-end-network-validation-strategy">7. End to end network validation strategy</h2> <p>A bring up strategy benefits from having both a general sanity check and an application specific test. This project uses two complementary tests that serve different purposes.</p> <p>The first test is a standard lwIP TCP echo server example. It listens on a TCP port and echoes back whatever bytes arrive. Because TCP is connection oriented and stream based, this test is particularly convenient for interactive validation using common tools. If a host can connect, send characters, and see them echoed back, then the network link, IP configuration, and the lwIP processing loop are working end to end. This test is intentionally independent of the Programmable Logic, so it isolates Ethernet and lwIP.</p> <p>The second test is the project’s custom lwIP UDP inverter application. This test is not interactive text. It defines a small binary protocol. The host sends exactly four bytes representing a 32 bit word in little endian byte order. The board writes that word into the output GPIO register, reads the inverted value from the input GPIO register, and replies with eight bytes containing the original word followed by the readback word. If the host receives a response and the second word equals the bitwise inversion of the first, then PS to PL register access is verified alongside networking.</p> <p class="img-fluid rounded z-depth-1 mx-auto d-block" style="width: 100%; max-width: 700px;"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_018.png" alt="This is a block diagram of a ZC702-based networked PS/PL test setup showing TCP/UDP apps in the Zynq PS, an AXI-Lite MMIO path into PL GPIO logic, and host test clients. Key elements - Left: Zynq PS with GEM0 MAC + lwIP running: - TCP Echo Server (port 6001) - UDP Inverter App (port 5005) - Right: Zynq PL datapath: - AXI GPIO OUT -&gt; 32-bit NOT -&gt; AXI GPIO IN - PL readback returned to the UDP app via AXI-Lite read/write - Host PC (Linux): - TCP client (telnet / nc) to validate TCP echo (echoes same bytes) - UDP client (host_udp_inverter.py) sends little-endian 4-byte u32 datagrams; UDP app returns an 8-byte reply containing written and read data (WR) - Validation notes shown: - Basic: link, IP config, lwIP TCP loop (no PL access) - Full: networking + PS-PL AXI-Lite MMIO + PL inverter datapath Arrows indicate control/data flow: Ethernet -&gt; lwIP apps -&gt; AXI-Lite MMIO -&gt; PL GPIO inverter -&gt; readback -&gt; host replies."/></p> <p><em>Figure 9: Testing architecture diagram showing the TCP echo test and the UDP inverter test and what each validates</em></p> <hr/> <h2 id="8-tcp-and-udp-in-this-project-why-both-exist-and-what-each-proves">8. TCP and UDP in this project: why both exist and what each proves</h2> <p>TCP and UDP are often compared in abstract terms, but this project illustrates the difference through concrete implementations.</p> <p>TCP, as used in the echo server example, is connection oriented. The server binds to a port, transitions into a listening state, and accepts client connections. Once a connection exists, data is exchanged as a byte stream. There is no inherent message boundary in TCP. If a client sends ten bytes, the server might receive them as one chunk or multiple chunks depending on buffering, timing, and flow control. The echo example simply writes back whatever bytes were received. This makes TCP echo an excellent bring up test because it does not require a custom application framing protocol. Any payload, including plain text, can be used immediately.</p> <p>UDP, as used in the inverter application, is connectionless. The server binds to a port and receives discrete datagrams. Each datagram preserves message boundaries, which makes UDP convenient for fixed size command response exchanges. In this design, the datagram boundary is treated as the application message boundary. The server expects exactly four bytes and rejects anything else. When the correct payload length is received, the server executes a single deterministic transaction against the PL registers and returns a single deterministic response. This is a better fit than TCP for a register style command protocol because the message is naturally framed and the overhead is lower.</p> <p>The two tests therefore serve different purposes. The TCP echo server demonstrates that Ethernet and lwIP are operational in a way that is easy to reproduce with generic tools and arbitrary payloads. The UDP inverter demonstrates that networking and PS to PL register access are working together in a deterministic, verifiable control loop.</p> <p class="img-fluid rounded z-depth-1 mx-auto d-block" style="width: 100%; max-width: 700px;"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_020.png" alt="Top panel (UDP - datagrams) - Shows a client sending discrete datagrams (Datagram A, 4 bytes; Datagram B, 4 bytes) to an &quot;Inverter Server&quot;. - Server processes each datagram independently and sends a reply per datagram. - Emphasizes message boundaries: each UDP packet is a separate unit. Bottom panel (TCP - stream) - Shows a client connected to an &quot;Echo Server&quot; over a byte stream. - A labeled box reads &quot;Byte stream - no message boundaries&quot;. - Arrows indicate continuous, bidirectional flow: data is sent and echoed back, but message boundaries are not preserved. Overall point: UDP preserves per-datagram message boundaries with one reply per datagram; TCP provides a continuous byte stream without inherent message boundaries, so framing must be handled by the application."/></p> <p><em>Figure 10: Protocol comparison diagram showing TCP as a stream and UDP as message framed datagrams</em></p> <hr/> <h2 id="9-simulation-only-validation-of-the-axi-gpio-loopback">9. Simulation-Only Validation of the AXI GPIO Loopback</h2> <p>To validate the PL inverter without hardware, I built a simulation-only block design. The AXI VIP acts as a stand-in for the PS, issuing AXI-Lite reads and writes. Those transactions pass through SmartConnect and reach two AXI GPIO blocks – one configured as output and one as input – with a 32-bit NOT between them. I exported the clock and reset as external ports (clk_in1_0, ext_reset_in_0) so the testbench could drive them directly. The proc_sys_reset and clocking wizard provide a realistic reset/clock environment, while the VIP gives full control of addresses and data from the testbench. This makes the simulation faithful to real AXI behavior but still simple and self-contained for regression testing. It should be noted that I configured the Clocking Wizard IP block reset to be active low as it is set to active high by default.</p> <p class="img-fluid rounded z-depth-1 mx-auto d-block" style="width: 100%; max-width: 700px;"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_022.png" alt="This is a Vivado-style block diagram of an AXI-based embedded design. Key elements: - Left: external inputs - clk_in1_0 and ext_reset_in_0 feed clk_wiz_0 (Clocking Wizard) producing clk_out1 and locked. - proc_sys_reset_0 (Processor System Reset) takes the clocks and reset inputs and produces various resets (mb_reset, bus_struct_reset, peripheral_reset, interconnect_aresetn, peripheral_aresetn). - Center: AXI master and interconnect - axi_vip_0 (AXI Verification IP) as an AXI master (M_AXI) connected to smartconnect_0. - smartconnect_0 (AXI SmartConnect) routes AXI transactions between the master and AXI peripherals. - Right: AXI peripherals and logic - Two AXI GPIO blocks: axi_gpio_in and axi_gpio_out connected as AXI slaves to the SmartConnect. - A utility block util_vector_logic_0 (labelled &quot;Discontinued&quot;) performing vector logic on the GPIO outputs; its Res31:0 driven by the GPIO outputs (Op31:0). - AXI control signals (S_AXI/M_AXI, aclk, aresetn, gpio_io_o/gpio_io_i) interconnect the modules; reset/clock nets from proc_sys_reset_0 and clk_wiz_0 are distributed to the AXI IPs."/></p> <p><em>Figure 11: Simulation-only block design for AXI-Lite verification (AXI VIP -&gt; SmartConnect -&gt; AXI GPIO IN/OUT with inverter)</em></p> <p>A 100 MHz clock is generated in the testbench (always #5 clk_in1 = ~clk_in1;), and reset is asserted low for several cycles before being released. Once reset deasserts, the AXI VIP master issues a sequence of AXI-Lite writes to the GPIO OUT base address (0x4121_0000) and immediately reads back from the GPIO IN base address (0x4120_0000). Each read is checked against the expected inverted value using a small pass/fail scoreboard inside the do_one() task. Test vectors cover a mix of corner cases and patterns as seen in the table below.</p> <table> <thead> <tr> <th style="text-align: center"><strong>Write (W)</strong></th> <th style="text-align: center"><strong>Expected Read (R = ~W)</strong></th> </tr> </thead> <tbody> <tr> <td style="text-align: center">0x00000000</td> <td style="text-align: center">0xFFFFFFFF</td> </tr> <tr> <td style="text-align: center">0xFFFFFFFF</td> <td style="text-align: center">0x00000000</td> </tr> <tr> <td style="text-align: center">0x12345678</td> <td style="text-align: center">0xEDCBA987</td> </tr> <tr> <td style="text-align: center">0xA5A5A5A5</td> <td style="text-align: center">0x5A5A5A5A</td> </tr> </tbody> </table> <p><em>Table 2: AXI GPIO inverter test vectors and expected readback</em></p> <p>On a successful run, the TCL console shows PASS messages for each vector followed by $finish, confirming that the AXI GPIO write/read path and the PL inverter are both functioning as seen in the figure below.</p> <p class="img-fluid rounded z-depth-1 mx-auto d-block" style="width: 100%; max-width: 700px;"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_023.png" alt="Screenshot of Xilinx Vivado (2025.2) showing a simulation workspace. Key visible items: - Left pane: Flow Navigator with sections like Project Manager, IP Integrator, Simulation, RTL Analysis, Synthesis, Implementation, Program and Debug. - Center-left: Sources/Hierarchy panel listing design files (axi_gpio_tb_wrapper, design_1_wrapper) and Simulation Sources (tb_axi_gpio_tb.sv). - Center-top: Main toolbar and simulation controls; simulation mode indicated as &quot;SIMULATION - Behavioral Simulation - Functional - sim_1&quot;. - Center-right: Text editor open on tb_axi_gpio_tb.sv (SystemVerilog testbench) with a highlighted line and visible code for driving and checking AXI GPIO transfers. - Bottom: Tcl Console / Messages pane showing simulation output lines like &quot;PASS: wrote 00000000 read ffffffff&quot;, several PASS messages, and a finish message with simulation time and file/line reference. - Right-top status: &quot;Synthesis and Implementation Out-of-date&quot; indicator."/></p> <p><em>Figure 12: XSim TCL console showing AXI-VIP PASS messages and end-of-simulation checks</em></p> <p>Figure 13 highlights the key AXI-Lite signals from the VIP master. clk_in1 is the 100MHz testbench clock; ext_reset is the active-low reset driven by the testbench; aclk is the AXI clock inside the BD (from the clocking wizard). m_axi_wdata[31:0] is the data written to GPIO OUT, m_axi_araddr[31:0] is the read address for GPIO IN, and m_axi_rdata[31:0] is the returned read data. resp[1:0] shows the AXI response code for each transaction, and rdata[31:0] is the testbench’s captured readback used in the comparison check.</p> <p class="img-fluid rounded z-depth-1 mx-auto d-block" style="width: 100%; max-width: 700px;"><img src="/assets/img/posts/post-1-zc702-ps-ethernet-over-mio-and-ps-to-pl-axi-loopback/image_024.png" alt="- Screenshot of a digital waveform viewer (testbench file name shown: tb_axi_gpio_tb_behav.wcfg). - Left column: signal list and current hex values (clk_in1, ext_reset, resp1:0, rdata31:0, aclk, m_axi_araddr31:0, m_axi_wdata31:0, m_axi_rdata31:0, etc.). - Main pane: time axis in nanoseconds (0 -&gt; 4,610,000 ns) and vertical grid lines. - Waveforms: clock signals (green) toggling, reset and response lines, and several bus traces shown as green/red waveforms with annotated data values like 5a5a5a5a, xxxxxxxx, ffffffff, 00000000, edcba987. - Typical viewer UI elements: zoom/toolbar at top, signal-value column between list and waveform."/></p> <p><em>Figure 13: Behavioral simulation waveform showing AXI-Lite writes to GPIO OUT and reads from GPIO IN returning the inverted data.</em></p> <hr/> <h2 id="10-summary-and-transition-to-implementation-details">10. Summary and transition to implementation details</h2> <p>This system overview established the key architectural decisions behind the project. Ethernet is implemented using GEM0 over MIO because the ZC702 board routes the onboard PHY to the Processing System’s dedicated Ethernet interface. The Programmable Logic exists to provide a minimal, deterministic datapath that can be exercised through memory mapped AXI Lite register accesses. The PS reaches the PL through the AXI general purpose port and an AXI interconnect, and two AXI GPIO peripherals expose a simple register interface for write and readback. Finally, validation is performed in two layers: a generic TCP echo server test to confirm the network stack, and a custom UDP inverter protocol to confirm the combined networking and PS to PL control path.</p> <p>The next post will focus on the hardware construction in Vivado. It will walk through the Processing System configuration for GEM0, the block design composition, address mapping, clock and reset wiring, bitstream generation, and XSA export for Vitis.</p>]]></content><author><name></name></author><category term="zynq"/><category term="zc702"/><category term="ethernet"/><category term="lwip"/><category term="axi"/><category term="vivado"/><category term="vitis"/><category term="ps-pl"/><summary type="html"><![CDATA[Minimal Zynq-7000 bring-up on ZC702 using PS GEM0 Ethernet and a simple PS-to-PL AXI loopback.]]></summary></entry></feed>